# ä¸­æ–‡èµ·åç½‘ç«™æŠ€æœ¯æ–¹æ¡ˆï¼ˆMVPç‰ˆï¼‰

## ğŸš€ åŸºäº Cloudflare Pages + Supabase çš„MVPæ–¹æ¡ˆ

**æ ¸å¿ƒç›®æ ‡ï¼š** å¿«é€Ÿä¸Šçº¿MVPï¼ŒéªŒè¯å¸‚åœºéœ€æ±‚
**å¼€å‘ç­–ç•¥ï¼š** ç²¾ç®€åŠŸèƒ½ï¼Œä¸“æ³¨æ ¸å¿ƒä»·å€¼
**é¢„ä¼°å‘¨æœŸï¼š** 18-20ä¸ªå·¥ä½œæ—¥
**æˆæœ¬é¢„ç®—ï¼š** AIæˆæœ¬ $80/å¤©ï¼ŒåŸºç¡€è®¾æ–½ <$50/æœˆ
**æŠ€æœ¯æ ˆï¼š** Next.js + Cloudflare Pages + Supabase + OpenAI

---

## ğŸ“Š MVPæ ¸å¿ƒåŠŸèƒ½

### P1 æ ¸å¿ƒåŠŸèƒ½ï¼ˆå¿…é¡»å®ç°ï¼‰
- âœ… ç”¨æˆ·æ³¨å†Œç™»å½•ï¼ˆSupabase Authï¼‰
- âœ… AIä¸­æ–‡èµ·åï¼ˆOpenAI GPT-4 Turboï¼‰
- âœ… åå­—ä¿å­˜å’Œæ”¶è—
- âœ… ç§¯åˆ†ç³»ç»Ÿå’Œæ”¯ä»˜ï¼ˆStripeï¼‰
- âœ… ç§»åŠ¨ç«¯é€‚é…

### P2 å¢å€¼åŠŸèƒ½ï¼ˆåç»­è¿­ä»£ï¼‰
- ğŸ”„ åå­—å‘éŸ³ï¼ˆTTSï¼‰
- ğŸ”„ ç®€å•ä¹¦æ³•ç”Ÿæˆ
- ğŸ”„ åˆ†äº«åŠŸèƒ½

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ ¸å¿ƒæŠ€æœ¯æ ˆï¼ˆMVPç²¾ç®€ç‰ˆï¼‰
```typescript
const mvpTechStack = {
  // å‰ç«¯æ¡†æ¶
  frontend: "Next.js 15 (App Router)",
  deployment: "Cloudflare Pages + @cloudflare/next-on-pages",

  // åç«¯æœåŠ¡
  database: "Supabase PostgreSQL + RLS",
  auth: "Supabase Auth (é‚®ç®±+OAuth)",
  storage: "Supabase Storage",

  // AIæœåŠ¡
  ai: {
    generation: "OpenAI GPT-4 Turbo",
    audio: "OpenAI TTS-1 (P2é˜¶æ®µ)"
  },

  // æ”¯ä»˜ç³»ç»Ÿ
  payment: "Stripe Checkout + Webhooks",

  // UIæ¡†æ¶
  ui: {
    styling: "Tailwind CSS",
    components: "Radix UI (åŸºç¡€ç»„ä»¶)",
    responsive: "Mobile-first"
  },

  // çŠ¶æ€ç®¡ç†
  state: "Reactå†…ç½®çŠ¶æ€ (useState/useEffect)",

  // ç¼“å­˜ç­–ç•¥
  cache: "Cloudflare KV + åº”ç”¨å±‚ç¼“å­˜",

  // ç›‘æ§å·¥å…·
  monitoring: "Sentry + è‡ªå®šä¹‰AIæˆæœ¬è¿½è¸ª"
}
```

### ç³»ç»Ÿæ¶æ„å›¾
```
ç”¨æˆ·æµè§ˆå™¨
    â†“
Cloudflare CDN
    â†“
Cloudflare Pages (Next.js SSR)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Pages Functions (Edge Runtime)   â”‚
â”‚  â€¢ app/api/generate-name                â”‚
â”‚  â€¢ app/api/stripe-webhook               â”‚
â”‚  â€¢ app/api/user-profile                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Supabase       â”‚ External APIs    â”‚
â”‚  â€¢ Auth         â”‚ â€¢ OpenAI GPT-4   â”‚
â”‚  â€¢ PostgreSQL   â”‚ â€¢ OpenAI TTS     â”‚
â”‚  â€¢ Storage      â”‚ â€¢ Stripe         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ åŠŸèƒ½æ¨¡å—è®¾è®¡

### æ ¸å¿ƒä¸šåŠ¡æ¨¡å—
```typescript
const coreModules = {
  // ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
  auth: {
    features: ["é‚®ç®±æ³¨å†Œ", "Google OAuth", "ä¼šè¯ç®¡ç†"],
    complexity: "ç®€å•",
    days: 2
  },

  // AIèµ·åå¼•æ“
  nameGeneration: {
    features: ["GPT-4èµ·å", "æˆæœ¬æ§åˆ¶", "ç»“æœç¼“å­˜"],
    complexity: "ä¸­ç­‰",
    days: 4
  },

  // ç”¨æˆ·é¢æ¿
  dashboard: {
    features: ["åå­—ç®¡ç†", "æ”¶è—åŠŸèƒ½", "å†å²è®°å½•"],
    complexity: "ç®€å•",
    days: 3
  },

  // æ”¯ä»˜ç³»ç»Ÿ
  payment: {
    features: ["Stripeé›†æˆ", "ç§¯åˆ†è´­ä¹°", "Webhookå¤„ç†"],
    complexity: "ä¸­ç­‰",
    days: 3
  }
}
```

### AIæˆæœ¬æ§åˆ¶ç­–ç•¥
```typescript
const costControl = {
  dailyBudget: 80, // $80/å¤©
  monthlyBudget: 2400, // $2400/æœˆ

  controls: {
    caching: "90%ç¼“å­˜å‘½ä¸­ç‡",
    rateLimit: "ç”¨æˆ·è¯·æ±‚é™åˆ¶",
    monitoring: "å®æ—¶æˆæœ¬è¿½è¸ª",
    alerts: "é¢„ç®—å‘Šè­¦æœºåˆ¶"
  },

  pricing: {
    freeUsers: "5æ¬¡/å¤©",
    paidUsers: "50æ¬¡/å¤©",
    costPerRequest: "$0.04-0.06"
  }
}
```

---

## ğŸ—ï¸ å¼€å‘å®æ–½è®¡åˆ’

### é¡¹ç›®åˆå§‹åŒ–ï¼ˆ1å¤©ï¼‰

```bash
# 1. åˆ›å»º Next.js é¡¹ç›®
npx create-next-app@latest chinesenamefinder --typescript --tailwind --app
cd chinesenamefinder

# 2. å®‰è£…æ ¸å¿ƒä¾èµ–
npm install @supabase/supabase-js @supabase/auth-ui-react
npm install @radix-ui/react-* lucide-react
npm install stripe openai
npm install @cloudflare/next-on-pages wrangler

# 3. å¼€å‘å·¥å…·
npm install -D @types/node typescript eslint prettier
npm install -D @sentry/nextjs
```

### é¡¹ç›®ç»“æ„ï¼ˆç²¾ç®€ç‰ˆï¼‰
```
chinesenamefinder/
â”œâ”€â”€ app/                          # Next.js App Router
â”‚   â”œâ”€â”€ api/                     # API è·¯ç”±
â”‚   â”‚   â”œâ”€â”€ generate-name/
â”‚   â”‚   â”œâ”€â”€ stripe-webhook/
â”‚   â”‚   â””â”€â”€ user-profile/
â”‚   â”œâ”€â”€ auth/                    # è®¤è¯é¡µé¢
â”‚   â”œâ”€â”€ dashboard/               # ç”¨æˆ·é¢æ¿
â”‚   â”œâ”€â”€ pricing/                 # å®šä»·é¡µé¢
â”‚   â””â”€â”€ page.tsx                 # é¦–é¡µ
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                      # åŸºç¡€ UI ç»„ä»¶
â”‚   â””â”€â”€ name-generator/          # èµ·åç›¸å…³ç»„ä»¶
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ supabase.ts              # Supabase å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ openai.ts                # OpenAI å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ stripe.ts                # Stripe å®¢æˆ·ç«¯
â”‚   â””â”€â”€ utils.ts                 # å·¥å…·å‡½æ•°
â”œâ”€â”€ types/                       # TypeScript ç±»å‹
â””â”€â”€ middleware.ts                # è·¯ç”±ä¸­é—´ä»¶
```

### æ ¸å¿ƒé…ç½®æ–‡ä»¶

#### next.config.mjs
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  trailingSlash: true,

  // Cloudflare Pages å›¾ç‰‡ä¼˜åŒ–
  images: {
    unoptimized: true
  },

  // å®‰å…¨å¤´éƒ¨
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          { key: 'X-Frame-Options', value: 'DENY' },
          { key: 'X-Content-Type-Options', value: 'nosniff' }
        ]
      }
    ]
  }
}

export default nextConfig
```

#### wrangler.toml
```toml
name = "chinesenamefinder"
compatibility_date = "2024-09-01"

[[kv_namespaces]]
binding = "NEXT_CACHE"
id = "your-kv-namespace-id"
```

### Supabase æ•°æ®åº“è®¾è®¡ï¼ˆMVPç®€åŒ–ç‰ˆï¼‰

```sql
-- MVP æ•°æ®åº“æ¶æ„ï¼ˆåªä¿ç•™æ ¸å¿ƒè¡¨ï¼‰

-- 1. ç”¨æˆ·è´¦æˆ·è¡¨
CREATE TABLE public.user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT NOT NULL,
  display_name TEXT,
  credits_remaining INTEGER DEFAULT 5,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. åå­—è®°å½•è¡¨
CREATE TABLE public.names (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  english_name TEXT NOT NULL,
  chinese_name TEXT NOT NULL,
  pinyin TEXT NOT NULL,
  meaning TEXT,
  style TEXT DEFAULT 'modern',
  is_favorite BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. æ”¯ä»˜è®°å½•è¡¨
CREATE TABLE public.payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  stripe_session_id TEXT UNIQUE,
  amount_cents INTEGER NOT NULL,
  credits_purchased INTEGER NOT NULL,
  status TEXT DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è¡Œçº§å®‰å…¨ç­–ç•¥
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.names ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "users_own_data" ON public.user_profiles
  FOR ALL USING (auth.uid() = id);
CREATE POLICY "users_own_names" ON public.names
  FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "users_own_payments" ON public.payments
  FOR SELECT USING (auth.uid() = user_id);

-- åŸºç¡€ç´¢å¼•
CREATE INDEX idx_names_user_created ON public.names(user_id, created_at DESC);
CREATE INDEX idx_names_favorites ON public.names(user_id) WHERE is_favorite = TRUE;
```

### Supabase å®¢æˆ·ç«¯é…ç½®

```typescript
// lib/supabase.ts
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

// å®¢æˆ·ç«¯
export const supabase = createClient(supabaseUrl, supabaseAnonKey)

// æœåŠ¡ç«¯ï¼ˆAPIè·¯ç”±ä½¿ç”¨ï¼‰
export const createServiceClient = () => {
  return createClient(
    supabaseUrl,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}
```

### ç”¨æˆ·è®¤è¯Hook

```typescript
// hooks/useAuth.ts
'use client'
import { useEffect, useState } from 'react'
import { User } from '@supabase/supabase-js'
import { supabase } from '@/lib/supabase'

export function useAuth() {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // è·å–åˆå§‹ç”¨æˆ·
    supabase.auth.getUser().then(({ data: { user } }) => {
      setUser(user)
      setLoading(false)
    })

    // ç›‘å¬è®¤è¯çŠ¶æ€
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        setUser(session?.user ?? null)
        setLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  return { user, loading }
}
```

### AIèµ·åå¼•æ“ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰

```typescript
// lib/openai.ts - ç®€åŒ–çš„AIæœåŠ¡
import OpenAI from 'openai'

interface NameRequest {
  englishName: string
  gender: 'male' | 'female' | 'neutral'
  style: 'traditional' | 'modern' | 'elegant'
}

interface NameResult {
  chinese: string
  pinyin: string
  meaning: string
}

export class NameGenerator {
  private openai: OpenAI
  private readonly DAILY_BUDGET = 80 // $80/å¤©
  private costTracker = new Map<string, number>()

  constructor(apiKey: string) {
    this.openai = new OpenAI({ apiKey })
  }

  async generateNames(request: NameRequest): Promise<NameResult[]> {
    // æˆæœ¬æ£€æŸ¥
    await this.checkBudget()

    const prompt = `ä¸º"${request.englishName}"ç”Ÿæˆ3ä¸ª${request.gender === 'male' ? 'ç”·æ€§' : request.gender === 'female' ? 'å¥³æ€§' : ''}ä¸­æ–‡åå­—ï¼Œ${request.style}é£æ ¼ã€‚è¿”å›JSONæ ¼å¼ã€‚`

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo',
      messages: [
        {
          role: 'system',
          content: 'ä¸­æ–‡èµ·åä¸“å®¶ã€‚è¿”å›JSON: {"names":[{"chinese":"ç‹æ˜","pinyin":"Wang Ming","meaning":"å…‰æ˜æ™ºæ…§"}]}'
        },
        { role: 'user', content: prompt }
      ],
      response_format: { type: 'json_object' },
      max_tokens: 800,
      temperature: 0.7
    })

    const result = JSON.parse(response.choices[0].message.content || '{}')

    // è®°å½•æˆæœ¬
    await this.trackCost(0.04) // ä¼°ç®—æ¯æ¬¡è¯·æ±‚$0.04

    return result.names || []
  }

  private async checkBudget(): Promise<void> {
    const today = new Date().toISOString().split('T')[0]
    const spent = this.costTracker.get(today) || 0

    if (spent >= this.DAILY_BUDGET) {
      throw new Error('ä»Šæ—¥AIé¢„ç®—å·²ç”¨å®Œï¼Œè¯·æ˜å¤©å†è¯•')
    }
  }

  private async trackCost(cost: number): Promise<void> {
    const today = new Date().toISOString().split('T')[0]
    const current = this.costTracker.get(today) || 0
    this.costTracker.set(today, current + cost)
  }
}
```

### APIè·¯ç”±å®ç°

```typescript
// app/api/generate-name/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { NameGenerator } from '@/lib/openai'
import { createServiceClient } from '@/lib/supabase'

export const runtime = 'edge'

export async function POST(request: NextRequest) {
  try {
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const authHeader = request.headers.get('Authorization')
    if (!authHeader) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 })
    }

    const token = authHeader.replace('Bearer ', '')
    const supabase = createServiceClient()

    const { data: { user }, error } = await supabase.auth.getUser(token)
    if (error || !user) {
      return NextResponse.json({ error: 'è®¤è¯å¤±è´¥' }, { status: 401 })
    }

    // æ£€æŸ¥ç§¯åˆ†
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('credits_remaining')
      .eq('id', user.id)
      .single()

    if (!profile || profile.credits_remaining <= 0) {
      return NextResponse.json({ error: 'ç§¯åˆ†ä¸è¶³' }, { status: 402 })
    }

    // ç”Ÿæˆåå­—
    const requestData = await request.json()
    const generator = new NameGenerator(process.env.OPENAI_API_KEY!)
    const names = await generator.generateNames(requestData)

    // ä¿å­˜ç»“æœå¹¶æ‰£é™¤ç§¯åˆ†
    await Promise.all([
      supabase.from('names').insert(
        names.map(name => ({
          user_id: user.id,
          english_name: requestData.englishName,
          chinese_name: name.chinese,
          pinyin: name.pinyin,
          meaning: name.meaning,
          style: requestData.style
        }))
      ),
      supabase
        .from('user_profiles')
        .update({ credits_remaining: profile.credits_remaining - 1 })
        .eq('id', user.id)
    ])

    return NextResponse.json({
      names,
      remainingCredits: profile.credits_remaining - 1
    })
  } catch (error) {
    console.error('Generate name error:', error)
    return NextResponse.json(
      { error: 'æœåŠ¡å™¨é”™è¯¯' },
      { status: 500 }
    )
  }
}
```

### Stripeæ”¯ä»˜é›†æˆ

```typescript
// app/api/create-payment/route.ts
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'
import { createServiceClient } from '@/lib/supabase'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)

export async function POST(request: NextRequest) {
  try {
    const { planType } = await request.json()

    const plans = {
      basic: { credits: 20, price: 999 }, // $9.99
      standard: { credits: 50, price: 1999 }, // $19.99
      premium: { credits: 100, price: 3499 } // $34.99
    }

    const plan = plans[planType as keyof typeof plans]
    if (!plan) {
      return NextResponse.json({ error: 'æ— æ•ˆè®¡åˆ’' }, { status: 400 })
    }

    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [{
        price_data: {
          currency: 'usd',
          product_data: {
            name: `ç§¯åˆ†åŒ… - ${plan.credits}ä¸ªç§¯åˆ†`
          },
          unit_amount: plan.price
        },
        quantity: 1
      }],
      mode: 'payment',
      success_url: `${process.env.NEXT_PUBLIC_SITE_URL}/dashboard?success=true`,
      cancel_url: `${process.env.NEXT_PUBLIC_SITE_URL}/pricing`,
      metadata: {
        credits: plan.credits.toString()
      }
    })

    return NextResponse.json({ url: session.url })
  } catch (error) {
    return NextResponse.json(
      { error: 'åˆ›å»ºæ”¯ä»˜ä¼šè¯å¤±è´¥' },
      { status: 500 }
    )
  }
}
```

```typescript
// app/api/stripe-webhook/route.ts
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'
import { createServiceClient } from '@/lib/supabase'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!

export async function POST(request: NextRequest) {
  try {
    const body = await request.text()
    const sig = request.headers.get('stripe-signature')!

    const event = stripe.webhooks.constructEvent(body, sig, endpointSecret)

    if (event.type === 'checkout.session.completed') {
      const session = event.data.object as Stripe.Checkout.Session
      const credits = parseInt(session.metadata?.credits || '0')

      // æ›´æ–°ç”¨æˆ·ç§¯åˆ†
      const supabase = createServiceClient()
      await supabase.rpc('add_credits', {
        user_email: session.customer_email,
        credits_to_add: credits
      })

      // è®°å½•æ”¯ä»˜
      await supabase.from('payments').insert({
        stripe_session_id: session.id,
        amount_cents: session.amount_total || 0,
        credits_purchased: credits,
        status: 'completed'
      })
    }

    return NextResponse.json({ received: true })
  } catch (error) {
    return NextResponse.json(
      { error: 'Webhookå¤„ç†å¤±è´¥' },
      { status: 400 }
    )
  }
}
```

---

## ğŸ“… å¼€å‘æ—¶é—´çº¿

### Week 1: åŸºç¡€æ¶æ„ï¼ˆ5å¤©ï¼‰
- **Day 1-2**: é¡¹ç›®åˆå§‹åŒ– + Supabaseé…ç½®
- **Day 3-4**: ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
- **Day 5**: åŸºç¡€UIç»„ä»¶

### Week 2: æ ¸å¿ƒåŠŸèƒ½ï¼ˆ5å¤©ï¼‰
- **Day 6-8**: AIèµ·åå¼•æ“å¼€å‘
- **Day 9**: ç”¨æˆ·é¢æ¿å’Œåå­—ç®¡ç†
- **Day 10**: åŠŸèƒ½æµ‹è¯•å’Œä¼˜åŒ–

### Week 3: æ”¯ä»˜å’Œéƒ¨ç½²ï¼ˆ5å¤©ï¼‰
- **Day 11-12**: Stripeæ”¯ä»˜é›†æˆ
- **Day 13**: éƒ¨ç½²é…ç½®å’Œä¼˜åŒ–
- **Day 14-15**: æµ‹è¯•å’Œä¸Šçº¿

### Week 4: ç¼“å†²æ—¶é—´ï¼ˆ3å¤©ï¼‰
- é—®é¢˜ä¿®å¤å’Œç»†èŠ‚ä¼˜åŒ–
- ç”¨æˆ·åé¦ˆæ”¶é›†
- æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜

---

## ğŸ† æˆåŠŸæŒ‡æ ‡

### MVPæˆåŠŸæ ‡å‡†ï¼ˆ3å‘¨åï¼‰
- **æŠ€æœ¯æŒ‡æ ‡**: 99%å¯ç”¨æ€§ï¼ŒAIæˆæœ¬<$80/å¤©
- **ä¸šåŠ¡æŒ‡æ ‡**: 50+æ³¨å†Œç”¨æˆ·ï¼Œ5+ä»˜è´¹ç”¨æˆ·
- **äº§å“æŒ‡æ ‡**: æ ¸å¿ƒåŠŸèƒ½100%å¯ç”¨

### éƒ¨ç½²é…ç½®

```yaml
# .github/workflows/deploy.yml
name: Deploy to Cloudflare Pages

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'

      - name: Install and Build
        run: |
          npm ci
          npx @cloudflare/next-on-pages@1 build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: chinesenamefinder
          directory: .vercel/output/static
```

### ç¯å¢ƒå˜é‡é…ç½®

```typescript
const requiredEnvVars = {
  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: "your-supabase-url",
  NEXT_PUBLIC_SUPABASE_ANON_KEY: "your-anon-key",
  SUPABASE_SERVICE_ROLE_KEY: "your-service-role-key",

  // OpenAI
  OPENAI_API_KEY: "your-openai-api-key",

  // Stripe
  STRIPE_SECRET_KEY: "your-stripe-secret-key",
  STRIPE_WEBHOOK_SECRET: "your-webhook-secret",
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: "your-publishable-key",

  // Cloudflare
  CLOUDFLARE_API_TOKEN: "your-api-token",
  CLOUDFLARE_ACCOUNT_ID: "your-account-id"
}
```

## ğŸ“‹ å®æ–½æ£€æŸ¥æ¸…å•

### âœ… å¼€å‘å‰å‡†å¤‡
- [ ] åˆ›å»ºSupabaseé¡¹ç›®å’Œæ•°æ®åº“
- [ ] è·å–OpenAI APIå¯†é’¥
- [ ] è®¾ç½®Stripeè´¦æˆ·å’ŒWebhook
- [ ] é…ç½®Cloudflare Pagesé¡¹ç›®
- [ ] è®¾ç½®GitHubä»“åº“å’ŒSecrets

### âœ… MVPæ ¸å¿ƒåŠŸèƒ½
- [ ] ç”¨æˆ·æ³¨å†Œç™»å½•ç³»ç»Ÿ
- [ ] AIèµ·åå¼•æ“å’Œæˆæœ¬æ§åˆ¶
- [ ] åå­—ä¿å­˜å’Œæ”¶è—åŠŸèƒ½
- [ ] ç§¯åˆ†ç³»ç»Ÿå’ŒStripeæ”¯ä»˜
- [ ] ç§»åŠ¨ç«¯å“åº”å¼è®¾è®¡

### âœ… éƒ¨ç½²å’Œç›‘æ§
- [ ] ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æˆåŠŸ
- [ ] APIå¥åº·æ£€æŸ¥ç«¯ç‚¹
- [ ] åŸºç¡€é”™è¯¯ç›‘æ§ï¼ˆSentryï¼‰
- [ ] AIæˆæœ¬å®æ—¶è¿½è¸ª
- [ ] ç”¨æˆ·åé¦ˆæ”¶é›†æœºåˆ¶

---

## ğŸ¯ æ€»ç»“

è¿™ä¸ªä¼˜åŒ–åçš„MVPæ–¹æ¡ˆå…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### âœ… æ ¸å¿ƒä¼˜åŠ¿
- **æŠ€æœ¯å¯è¡Œ**: åŸºäº@cloudflare/next-on-pagesè§£å†³æ–¹æ¡ˆï¼Œæ¶æ„ç¨³å®š
- **æˆæœ¬å¯æ§**: AIé¢„ç®—$80/å¤©ï¼ŒåŸºç¡€è®¾æ–½<$50/æœˆ
- **å¼€å‘é«˜æ•ˆ**: 18-20å¤©å®ŒæˆMVPï¼Œå¿«é€ŸéªŒè¯å¸‚åœº
- **æ‰©å±•çµæ´»**: æ¸…æ™°çš„æ¨¡å—åŒ–è®¾è®¡ï¼Œä¾¿äºåç»­è¿­ä»£

### ğŸ“ˆ é¢„æœŸæˆæœ
- **3å‘¨å†…**: MVPä¸Šçº¿ï¼Œæ ¸å¿ƒåŠŸèƒ½å¯ç”¨
- **1ä¸ªæœˆå†…**: è·å¾—é¦–æ‰¹ç”¨æˆ·åé¦ˆï¼ŒéªŒè¯äº§å“éœ€æ±‚
- **3ä¸ªæœˆå†…**: åŸºäºç”¨æˆ·åé¦ˆä¼˜åŒ–äº§å“ï¼Œå®ç°äº§å“-å¸‚åœºåŒ¹é…

è¿™ä¸ªæ–¹æ¡ˆå¹³è¡¡äº†æŠ€æœ¯å¯è¡Œæ€§ã€å¼€å‘æ•ˆç‡å’Œæˆæœ¬æ§åˆ¶ï¼Œä¸ºä¸­æ–‡èµ·åç½‘ç«™çš„å¿«é€Ÿä¸Šçº¿å’Œè¿­ä»£ä¼˜åŒ–æä¾›äº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚

---

## ğŸš€ å®Œæ•´äº§å“æŠ€æœ¯è·¯çº¿å›¾

åŸºäºPRDéœ€æ±‚åˆ†æå’Œcriteria-anyship-templateæ¨¡æ¿åŠŸèƒ½ï¼Œä»¥ä¸‹æ˜¯ä»MVPåˆ°å®Œæ•´äº§å“çš„æŠ€æœ¯å®æ–½æ–¹æ¡ˆï¼š

---

## ğŸ“‹ Phase 2: æ ¸å¿ƒåŠŸèƒ½æ‰©å±•ï¼ˆç¬¬2-3æœˆï¼‰

### å¢å€¼æœåŠ¡æ¨¡å—

#### 2.1 AIäº”è¡Œå‘½åç³»ç»Ÿ
```typescript
// lib/wuxing.ts - äº”è¡Œå‘½åå¼•æ“
interface BirthInfo {
  date: string // YYYY-MM-DD
  time: string // HH:MM
  timezone: string // Asia/Shanghai
  gender: 'male' | 'female' | 'neutral'
}

interface WuxingAnalysis {
  elements: {
    metal: number    // é‡‘
    wood: number     // æœ¨
    water: number    // æ°´
    fire: number     // ç«
    earth: number    // åœŸ
  }
  lacking: string[]  // ç¼ºå¤±å…ƒç´ 
  strong: string[]   // å¼ºåŠ¿å…ƒç´ 
  suggestions: string[] // å‘½åå»ºè®®
}

export class WuxingNameEngine {
  private calendar: ChineseCalendar

  constructor() {
    this.calendar = new ChineseCalendar()
  }

  async analyzeBirth(birthInfo: BirthInfo): Promise<WuxingAnalysis> {
    // 1. è½¬æ¢ä¸ºå†œå†
    const lunarDate = this.calendar.solarToLunar(birthInfo.date)

    // 2. è®¡ç®—å…«å­—
    const bazi = this.calculateBaZi(lunarDate, birthInfo.time)

    // 3. äº”è¡Œåˆ†æ
    const elements = this.analyzeWuxing(bazi)

    // 4. ç”Ÿæˆå»ºè®®
    const suggestions = this.generateSuggestions(elements, birthInfo.gender)

    return {
      elements,
      lacking: elements.lacking,
      strong: elements.strong,
      suggestions
    }
  }

  async generateWuxingNames(analysis: WuxingAnalysis, baseName: string): Promise<NameResult[]> {
    const prompt = this.buildWuxingPrompt(analysis, baseName)

    // è°ƒç”¨OpenAIç”Ÿæˆç¬¦åˆäº”è¡Œè¦æ±‚çš„åå­—
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo',
      messages: [
        { role: 'system', content: WUXING_SYSTEM_PROMPT },
        { role: 'user', content: prompt }
      ],
      response_format: { type: 'json_object' },
      temperature: 0.7
    })

    return this.parseWuxingResults(response, analysis)
  }
}
```

#### 2.2 è¯—æ„å‘½åç³»ç»Ÿ
```typescript
// lib/poetry.ts - è¯—æ„å‘½åå¼•æ“
interface PoetrySource {
  id: string
  title: string        // è¯—è¯æ ‡é¢˜
  author: string       // ä½œè€…
  dynasty: string      // æœä»£
  content: string      // åŸæ–‡
  translation: string  // ç°ä»£è¯‘æ–‡
  theme: string[]      // ä¸»é¢˜æ ‡ç­¾
}

export class PoetryNameEngine {
  private poetryDB: PoetryDatabase
  private vectorSearch: VectorSearch

  async generatePoetryNames(
    theme: string,
    gender: 'male' | 'female' | 'neutral',
    style: 'classical' | 'elegant' | 'nature'
  ): Promise<PoetryNameResult[]> {

    // 1. å‘é‡æœç´¢ç›¸å…³è¯—è¯
    const poems = await this.vectorSearch.searchByTheme(theme, style)

    // 2. ç­›é€‰é€‚åˆå‘½åçš„è¯—å¥
    const namingVerses = this.filterNamingVerses(poems, gender)

    // 3. AIæå–å‘½åçµæ„Ÿ
    const nameIdeas = await this.extractNameIdeas(namingVerses)

    // 4. ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
    return nameIdeas.map(idea => ({
      name: idea.name,
      pinyin: idea.pinyin,
      meaning: idea.meaning,
      source: idea.source,
      report: this.generatePoetryReport(idea)
    }))
  }

  private async generatePoetryReport(nameIdea: NameIdea): Promise<PoetryReport> {
    return {
      originalVerse: nameIdea.source.content,
      author: nameIdea.source.author,
      dynasty: nameIdea.source.dynasty,
      translation: nameIdea.source.translation,
      culturalContext: await this.getCulturalContext(nameIdea.source),
      namingInspiration: nameIdea.inspiration,
      literaryAnalysis: await this.getLiteraryAnalysis(nameIdea.source)
    }
  }
}
```

#### 2.3 æ™ºèƒ½ä¹¦æ³•ç”Ÿæˆç³»ç»Ÿ
```typescript
// lib/calligraphy.ts - ä¹¦æ³•ç”Ÿæˆå¼•æ“
interface CalligraphyOptions {
  name: string
  style: 'kaishu' | 'xingshu' | 'caoshu' | 'lishu' | 'zhuanshu'
  layout: 'horizontal' | 'vertical' | 'square'
  background: 'paper' | 'silk' | 'stone' | 'transparent'
  resolution: 'standard' | 'high' | 'print'
}

export class CalligraphyEngine {
  private sdClient: StableDiffusionClient
  private stylePrompts: Map<string, string>

  constructor() {
    this.initializeStylePrompts()
  }

  async generateCalligraphy(options: CalligraphyOptions): Promise<CalligraphyResult> {
    // 1. æ„å»ºStable Diffusionæç¤ºè¯
    const prompt = this.buildCalligraphyPrompt(options)

    // 2. ç”Ÿæˆä¹¦æ³•å›¾åƒ
    const image = await this.sdClient.textToImage({
      prompt,
      negative_prompt: CALLIGRAPHY_NEGATIVE_PROMPT,
      width: this.getResolutionWidth(options.resolution),
      height: this.getResolutionHeight(options.resolution),
      steps: 30,
      cfg_scale: 7,
      sampler: 'DPM++ 2M Karras'
    })

    // 3. åå¤„ç†ä¼˜åŒ–
    const optimizedImage = await this.postProcessCalligraphy(image, options)

    // 4. ç”Ÿæˆå¤šç§æ ¼å¼
    const formats = await this.generateMultipleFormats(optimizedImage)

    return {
      original: optimizedImage,
      formats,
      metadata: this.generateMetadata(options),
      downloadUrls: await this.uploadToStorage(formats)
    }
  }

  private buildCalligraphyPrompt(options: CalligraphyOptions): string {
    const basePrompt = `Chinese calligraphy of "${options.name}"`
    const stylePrompt = this.stylePrompts.get(options.style)
    const layoutPrompt = this.getLayoutPrompt(options.layout)
    const backgroundPrompt = this.getBackgroundPrompt(options.background)

    return `${basePrompt}, ${stylePrompt}, ${layoutPrompt}, ${backgroundPrompt}, masterpiece, high quality, traditional Chinese art`
  }
}
```

### æ¸è¿›å¼æ•°æ®åº“æ¼”è¿›è®¾è®¡

#### Phase 1.5: MVPæ‰©å±•ï¼ˆæ— ç ´åæ€§å˜æ›´ï¼‰
```sql
-- æ‰©å±•ç°æœ‰è¡¨ç»“æ„ï¼Œä¿æŒå‘ä¸‹å…¼å®¹
ALTER TABLE public.user_profiles ADD COLUMN IF NOT EXISTS
  preferences JSONB DEFAULT '{}', -- ç”¨æˆ·åå¥½è®¾ç½®
  subscription_tier TEXT DEFAULT 'free', -- è®¢é˜…ç­‰çº§
  cultural_preferences JSONB DEFAULT '{}', -- æ–‡åŒ–åå¥½
  updated_at TIMESTAMPTZ DEFAULT NOW();

ALTER TABLE public.names ADD COLUMN IF NOT EXISTS
  generation_type TEXT DEFAULT 'basic', -- 'basic', 'wuxing', 'poetry'
  source_data JSONB DEFAULT '{}', -- æ‰©å±•æ•°æ®å­˜å‚¨
  quality_score INTEGER CHECK (quality_score BETWEEN 1 AND 100),
  metadata JSONB DEFAULT '{}'; -- å…ƒæ•°æ®ï¼ˆäº”è¡Œã€è¯—è¯æ¥æºç­‰ï¼‰

-- æ–°å¢å†…å®¹ç®¡ç†è¡¨ï¼ˆç®€åŒ–è®¾è®¡ï¼‰
CREATE TABLE IF NOT EXISTS public.content_sources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN ('poetry', 'cultural_data', 'calligraphy_template')),
  title TEXT NOT NULL,
  content_data JSONB NOT NULL, -- å­˜å‚¨è¯—è¯ã€æ–‡åŒ–çŸ¥è¯†ç­‰
  tags TEXT[], -- ä¸»é¢˜æ ‡ç­¾
  search_text TEXT, -- å…¨æ–‡æœç´¢å­—æ®µ
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç”¨æˆ·ä½œå“è¡¨ï¼ˆç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç±»å‹ä½œå“ï¼‰
CREATE TABLE IF NOT EXISTS public.user_works (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  name_id UUID REFERENCES public.names(id),
  work_type TEXT NOT NULL CHECK (work_type IN ('calligraphy', 'cultural_report', 'shared_story')),
  work_data JSONB NOT NULL, -- ä½œå“æ•°æ®
  is_public BOOLEAN DEFAULT FALSE,
  likes_count INTEGER DEFAULT 0,
  views_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºæœç´¢ä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_content_sources_type_tags ON public.content_sources USING GIN(type, tags);
CREATE INDEX IF NOT EXISTS idx_content_sources_search ON public.content_sources USING GIN(to_tsvector('chinese', search_text));
CREATE INDEX IF NOT EXISTS idx_user_works_type_public ON public.user_works(work_type, is_public) WHERE is_public = TRUE;
CREATE INDEX IF NOT EXISTS idx_names_generation_type ON public.names(generation_type, created_at DESC);

-- è¡Œçº§å®‰å…¨ç­–ç•¥
ALTER TABLE public.content_sources ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_works ENABLE ROW LEVEL SECURITY;

CREATE POLICY "content_sources_public_read" ON public.content_sources
  FOR SELECT USING (true); -- å†…å®¹æºå…¬å¼€å¯è¯»

CREATE POLICY "users_own_works" ON public.user_works
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "public_works_readable" ON public.user_works
  FOR SELECT USING (is_public = TRUE OR auth.uid() = user_id);
```

#### Phase 2+: æŒ‰éœ€æ‰©å±•ç­–ç•¥
```sql
-- ä»…åœ¨çœŸæ­£éœ€è¦æ—¶æ‰æ‰©å±•ï¼Œé¿å…è¿‡åº¦è®¾è®¡

-- ä¼ä¸šå®¢æˆ·è¡¨ï¼ˆä»…B2Bé˜¶æ®µéœ€è¦ï¼‰
CREATE TABLE IF NOT EXISTS public.enterprise_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  company_name TEXT NOT NULL,
  contact_info JSONB NOT NULL, -- è”ç³»ä¿¡æ¯
  subscription_data JSONB DEFAULT '{}', -- è®¢é˜…æ•°æ®
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ†ææ•°æ®è¡¨ï¼ˆç®€åŒ–ç‰ˆï¼Œé¿å…å¼•å…¥ClickHouseï¼‰
CREATE TABLE IF NOT EXISTS public.usage_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  event_type TEXT NOT NULL,
  event_data JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- æŒ‰æœˆåˆ†åŒºï¼Œä¾¿äºæ•°æ®ç®¡ç†
CREATE TABLE public.usage_analytics_current PARTITION OF public.usage_analytics
  FOR VALUES FROM (date_trunc('month', CURRENT_DATE)) TO (date_trunc('month', CURRENT_DATE + interval '1 month'));

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_analytics_user_type_time ON public.usage_analytics(user_id, event_type, created_at DESC);
CREATE INDEX idx_analytics_type_time ON public.usage_analytics(event_type, created_at DESC) WHERE created_at >= CURRENT_DATE - interval '30 days';
```

#### æ•°æ®è¿ç§»ç­–ç•¥
```sql
-- å¹³æ»‘è¿ç§»å‡½æ•°ï¼Œä¿è¯é›¶åœæœº
CREATE OR REPLACE FUNCTION migrate_name_data()
RETURNS void AS $$
BEGIN
  -- å°†ç°æœ‰åŸºç¡€åå­—æ ‡è®°ä¸º 'basic' ç±»å‹
  UPDATE public.names
  SET generation_type = 'basic',
      metadata = '{"version": "1.0", "migration": "auto"}'
  WHERE generation_type IS NULL;

  -- åˆ›å»ºå†…å®¹æœç´¢ç´¢å¼•
  INSERT INTO public.content_sources (type, title, content_data, tags, search_text)
  SELECT 'poetry', 'é»˜è®¤è¯—è¯åº“', '{"status": "placeholder"}', ARRAY['classical'], 'è¯—è¯'
  WHERE NOT EXISTS (SELECT 1 FROM public.content_sources WHERE type = 'poetry');
END;
$$ LANGUAGE plpgsql;
```

#### æœç´¢ä¼˜åŒ–ï¼ˆé¿å…å‘é‡æœç´¢å¤æ‚æ€§ï¼‰
```sql
-- åŸºäºPostgreSQLå…¨æ–‡æœç´¢ï¼Œæ— éœ€é¢å¤–æ‰©å±•
CREATE OR REPLACE FUNCTION search_poetry_content(
  search_term TEXT,
  theme_filter TEXT[] DEFAULT NULL
) RETURNS TABLE (
  id UUID,
  title TEXT,
  content_data JSONB,
  relevance REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cs.id,
    cs.title,
    cs.content_data,
    ts_rank(to_tsvector('chinese', cs.search_text), plainto_tsquery('chinese', search_term)) AS relevance
  FROM public.content_sources cs
  WHERE cs.type = 'poetry'
    AND to_tsvector('chinese', cs.search_text) @@ plainto_tsquery('chinese', search_term)
    AND (theme_filter IS NULL OR cs.tags && theme_filter)
  ORDER BY relevance DESC
  LIMIT 20;
END;
$$ LANGUAGE plpgsql;
```

---

## ğŸ“± Phase 3: ç”¨æˆ·ä½“éªŒå¢å¼ºï¼ˆç¬¬4-5æœˆï¼‰

### 3.1 å‘éŸ³è¯„æµ‹ç³»ç»Ÿ

```typescript
// lib/pronunciation.ts - å‘éŸ³è¯„æµ‹å¼•æ“
interface PronunciationAssessment {
  name: string
  userAudio: Blob
  targetPinyin: string
}

interface AssessmentResult {
  overallScore: number // 0-100
  toneAccuracy: number
  pronunciationAccuracy: number
  fluency: number
  feedback: PronunciationFeedback[]
  suggestions: string[]
}

export class PronunciationEngine {
  private speechSDK: AzureSpeechSDK

  async assessPronunciation(assessment: PronunciationAssessment): Promise<AssessmentResult> {
    // 1. ä¸Šä¼ éŸ³é¢‘åˆ°ä¸´æ—¶å­˜å‚¨
    const audioUrl = await this.uploadTempAudio(assessment.userAudio)

    // 2. è°ƒç”¨Azureè¯­éŸ³è¯„æµ‹API
    const result = await this.speechSDK.pronunciationAssessment({
      audioUrl,
      referenceText: assessment.targetPinyin,
      language: 'zh-CN',
      granularity: 'phoneme'
    })

    // 3. è§£æè¯„æµ‹ç»“æœ
    const scores = this.parseAssessmentScores(result)

    // 4. ç”Ÿæˆä¸ªæ€§åŒ–å»ºè®®
    const suggestions = await this.generateSuggestions(scores, assessment.targetPinyin)

    return {
      overallScore: scores.overall,
      toneAccuracy: scores.tone,
      pronunciationAccuracy: scores.pronunciation,
      fluency: scores.fluency,
      feedback: scores.feedback,
      suggestions
    }
  }

  async generatePronunciationGuide(name: string, pinyin: string): Promise<PronunciationGuide> {
    // ç”Ÿæˆå‘éŸ³æŒ‡å¯¼éŸ³é¢‘å’Œå¯è§†åŒ–å›¾è¡¨
    const nativeAudio = await this.generateNativeAudio(pinyin)
    const toneChart = await this.generateToneChart(pinyin)
    const phoneticBreakdown = this.analyzePhonetics(pinyin)

    return {
      nativeAudio,
      toneChart,
      phoneticBreakdown,
      practiceExercises: this.generatePracticeExercises(pinyin)
    }
  }
}
```

### 3.2 ç¤¾äº¤åˆ†äº«ç³»ç»Ÿ

```typescript
// lib/sharing.ts - åˆ†äº«åŠŸèƒ½å¼•æ“
interface ShareContent {
  type: 'name' | 'calligraphy' | 'culture_report'
  id: string
  customMessage?: string
  platforms: SocialPlatform[]
}

interface ShareResult {
  shareUrl: string
  previewCard: ShareCard
  analytics: ShareAnalytics
}

export class SharingEngine {
  async createShareContent(content: ShareContent): Promise<ShareResult> {
    // 1. ç”Ÿæˆåˆ†äº«é¡µé¢
    const shareUrl = await this.generateSharePage(content)

    // 2. åˆ›å»ºé¢„è§ˆå¡ç‰‡
    const previewCard = await this.generatePreviewCard(content)

    // 3. è®¾ç½®åˆ†æè¿½è¸ª
    const analytics = this.setupShareAnalytics(content)

    return { shareUrl, previewCard, analytics }
  }

  private async generateSharePage(content: ShareContent): Promise<string> {
    const shareId = generateShareId()

    // åˆ›å»ºé™æ€åˆ†äº«é¡µé¢
    const shareData = await this.getShareData(content)
    const htmlContent = await this.renderShareTemplate(shareData)

    // ä¸Šä¼ åˆ°Cloudflare Pages
    await this.uploadSharePage(shareId, htmlContent)

    return `${process.env.NEXT_PUBLIC_SITE_URL}/share/${shareId}`
  }

  private async generatePreviewCard(content: ShareContent): Promise<ShareCard> {
    // æ ¹æ®å†…å®¹ç±»å‹ç”Ÿæˆä¸åŒçš„é¢„è§ˆå¡ç‰‡
    switch (content.type) {
      case 'name':
        return this.generateNameCard(content.id)
      case 'calligraphy':
        return this.generateCalligraphyCard(content.id)
      case 'culture_report':
        return this.generateReportCard(content.id)
      default:
        throw new Error('Unsupported content type')
    }
  }
}
```

### 3.3 ç”¨æˆ·ä½œå“ç”»å»Š

```typescript
// components/gallery/UserGallery.tsx
interface GalleryWork {
  id: string
  type: 'name' | 'calligraphy' | 'story'
  title: string
  author: User
  thumbnail: string
  likes: number
  views: number
  tags: string[]
  createdAt: Date
  isPublic: boolean
}

export function UserGallery() {
  const [works, setWorks] = useState<GalleryWork[]>([])
  const [filter, setFilter] = useState<GalleryFilter>('all')
  const [sortBy, setSortBy] = useState<SortOption>('popular')

  return (
    <div className="gallery-container">
      <GalleryFilters
        currentFilter={filter}
        onFilterChange={setFilter}
        sortBy={sortBy}
        onSortChange={setSortBy}
      />

      <InfiniteScroll
        items={works}
        renderItem={(work) => (
          <GalleryWorkCard
            work={work}
            onLike={handleLike}
            onShare={handleShare}
            onView={handleView}
          />
        )}
        loadMore={loadMoreWorks}
        hasMore={hasMoreWorks}
      />
    </div>
  )
}

// ç¤¾åŒºäº’åŠ¨åŠŸèƒ½
export function GalleryWorkCard({ work, onLike, onShare, onView }: GalleryWorkCardProps) {
  return (
    <Card className="gallery-work-card">
      <CardHeader>
        <div className="flex items-center justify-between">
          <UserAvatar user={work.author} />
          <DropdownMenu>
            <DropdownMenuTrigger>
              <MoreHorizontal className="h-4 w-4" />
            </DropdownMenuTrigger>
            <DropdownMenuContent>
              <DropdownMenuItem onClick={() => onShare(work.id)}>
                åˆ†äº«ä½œå“
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => window.open(`/works/${work.id}`)}>
                æŸ¥çœ‹è¯¦æƒ…
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </CardHeader>

      <CardContent>
        <WorkPreview work={work} onClick={() => onView(work.id)} />
        <WorkMetadata work={work} />
      </CardContent>

      <CardFooter>
        <div className="flex items-center justify-between w-full">
          <div className="flex items-center space-x-4">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onLike(work.id)}
              className="flex items-center space-x-1"
            >
              <Heart className="h-4 w-4" />
              <span>{work.likes}</span>
            </Button>
            <span className="text-sm text-muted-foreground">
              {work.views} æ¬¡æŸ¥çœ‹
            </span>
          </div>
          <WorkTags tags={work.tags} />
        </div>
      </CardFooter>
    </Card>
  )
}
```

---

## ğŸ¢ Phase 4: B2Bä¼ä¸šæœåŠ¡ï¼ˆç¬¬6-7æœˆï¼‰

### 4.1 ä¼ä¸šå‘½åæœåŠ¡å¹³å°

```typescript
// app/api/enterprise/naming/route.ts
interface EnterpriseNamingRequest {
  companyInfo: {
    name: string
    industry: string
    targetMarket: string[]
    brandValues: string[]
  }
  namingRequirements: {
    type: 'brand' | 'product' | 'subsidiary'
    style: 'modern' | 'traditional' | 'international'
    length: 'short' | 'medium' | 'long'
    avoidWords: string[]
    preferredElements: string[]
  }
  budget: 'basic' | 'professional' | 'premium'
  timeline: string
}

interface EnterpriseNamingResult {
  proposals: EnterpriseNameProposal[]
  marketAnalysis: MarketAnalysis
  trademarkCheck: TrademarkReport
  culturalReport: CulturalValidation
  recommendedNext: string[]
}

export async function POST(request: NextRequest) {
  const namingRequest: EnterpriseNamingRequest = await request.json()

  // 1. éªŒè¯ä¼ä¸šèº«ä»½å’Œæƒé™
  const user = await authenticateEnterpriseUser(request)
  if (!user || user.accountType !== 'enterprise') {
    return NextResponse.json({ error: 'éœ€è¦ä¼ä¸šè´¦æˆ·æƒé™' }, { status: 403 })
  }

  // 2. åˆ›å»ºä¼ä¸šå‘½åé¡¹ç›®
  const project = await createNamingProject(namingRequest, user.id)

  // 3. AIç”Ÿæˆå€™é€‰åç§°
  const proposals = await generateEnterpriseNames(namingRequest)

  // 4. å¸‚åœºåˆ†æå’ŒéªŒè¯
  const marketAnalysis = await performMarketAnalysis(proposals, namingRequest.companyInfo)

  // 5. å•†æ ‡å¯ç”³è¯·æ€§æ£€æŸ¥
  const trademarkCheck = await checkTrademarkAvailability(proposals)

  // 6. æ–‡åŒ–é€‚é…æ€§éªŒè¯
  const culturalReport = await validateCulturalAppropriateness(proposals, namingRequest.companyInfo.targetMarket)

  // 7. ç”Ÿæˆç»¼åˆæŠ¥å‘Š
  const result: EnterpriseNamingResult = {
    proposals,
    marketAnalysis,
    trademarkCheck,
    culturalReport,
    recommendedNext: generateRecommendations(proposals, marketAnalysis)
  }

  // 8. ä¿å­˜é¡¹ç›®ç»“æœ
  await saveProjectResults(project.id, result)

  return NextResponse.json(result)
}

async function generateEnterpriseNames(request: EnterpriseNamingRequest): Promise<EnterpriseNameProposal[]> {
  const enterprisePrompt = buildEnterprisePrompt(request)

  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo',
    messages: [
      { role: 'system', content: ENTERPRISE_NAMING_SYSTEM_PROMPT },
      { role: 'user', content: enterprisePrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.8
  })

  const rawResults = JSON.parse(response.choices[0].message.content || '{}')

  // å¢å¼ºæ¯ä¸ªææ¡ˆçš„è¯¦ç»†ä¿¡æ¯
  return Promise.all(rawResults.proposals.map(async (proposal: any) => ({
    ...proposal,
    marketingAngles: await generateMarketingAngles(proposal),
    competitorAnalysis: await analyzeCompetitors(proposal, request.companyInfo.industry),
    brandingStrategy: await generateBrandingStrategy(proposal),
    riskAssessment: await assessNamingRisks(proposal)
  })))
}
```

### 4.2 ä¼ä¸šç®¡ç†åå°

```typescript
// app/[locale]/(admin)/enterprise/projects/page.tsx
export default function EnterpriseProjectsPage() {
  const [projects, setProjects] = useState<EnterpriseProject[]>([])
  const [filter, setFilter] = useState<ProjectFilter>('all')

  return (
    <div className="enterprise-dashboard">
      <DashboardHeader />

      <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
        <StatCard
          title="è¿›è¡Œä¸­é¡¹ç›®"
          value={projects.filter(p => p.status === 'in_progress').length}
          icon={<Clock className="h-4 w-4" />}
        />
        <StatCard
          title="å·²å®Œæˆé¡¹ç›®"
          value={projects.filter(p => p.status === 'completed').length}
          icon={<CheckCircle className="h-4 w-4" />}
        />
        <StatCard
          title="æœ¬æœˆæ”¶å…¥"
          value={`$${calculateMonthlyRevenue(projects)}`}
          icon={<DollarSign className="h-4 w-4" />}
        />
        <StatCard
          title="å®¢æˆ·æ»¡æ„åº¦"
          value={`${calculateSatisfactionRate(projects)}%`}
          icon={<Star className="h-4 w-4" />}
        />
      </div>

      <ProjectFilters filter={filter} onFilterChange={setFilter} />

      <ProjectsTable
        projects={filteredProjects}
        onProjectClick={handleProjectClick}
        onStatusUpdate={handleStatusUpdate}
      />
    </div>
  )
}

// ä¼ä¸šå®¢æˆ·å…³ç³»ç®¡ç†
function ProjectsTable({ projects, onProjectClick, onStatusUpdate }: ProjectsTableProps) {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>é¡¹ç›®åç§°</TableHead>
          <TableHead>å®¢æˆ·</TableHead>
          <TableHead>ç±»å‹</TableHead>
          <TableHead>çŠ¶æ€</TableHead>
          <TableHead>é¢„ç®—</TableHead>
          <TableHead>æˆªæ­¢æ—¥æœŸ</TableHead>
          <TableHead>æ“ä½œ</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {projects.map((project) => (
          <TableRow key={project.id}>
            <TableCell>
              <button
                onClick={() => onProjectClick(project.id)}
                className="font-medium text-blue-600 hover:underline"
              >
                {project.name}
              </button>
            </TableCell>
            <TableCell>
              <div className="flex items-center space-x-2">
                <Avatar className="h-8 w-8">
                  <AvatarImage src={project.client.avatar} />
                  <AvatarFallback>{project.client.name.charAt(0)}</AvatarFallback>
                </Avatar>
                <span>{project.client.name}</span>
              </div>
            </TableCell>
            <TableCell>
              <Badge variant={getTypeVariant(project.type)}>
                {project.type}
              </Badge>
            </TableCell>
            <TableCell>
              <StatusBadge
                status={project.status}
                onUpdate={(newStatus) => onStatusUpdate(project.id, newStatus)}
              />
            </TableCell>
            <TableCell>${project.budget.toLocaleString()}</TableCell>
            <TableCell>{formatDate(project.deadline)}</TableCell>
            <TableCell>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" className="h-8 w-8 p-0">
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onProjectClick(project.id)}>
                    æŸ¥çœ‹è¯¦æƒ…
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => downloadProjectReport(project.id)}>
                    ä¸‹è½½æŠ¥å‘Š
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => contactClient(project.client.id)}>
                    è”ç³»å®¢æˆ·
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}
```

---

## ğŸ”§ å®Œæ•´æŠ€æœ¯æ¶æ„è¿›é˜¶ç‰ˆ

### æ•°æ®åº“è®¾è®¡åŸåˆ™

**ğŸ“‹ è®¾è®¡ç†å¿µï¼šæ¸è¿›å¼æ¼”è¿›ï¼Œé¿å…è¿‡åº¦å·¥ç¨‹åŒ–**

1. **MVPé˜¶æ®µï¼š** ä¿æŒ3å¼ æ ¸å¿ƒè¡¨çš„ç®€æ´æ€§
2. **æ‰©å±•é˜¶æ®µï¼š** é€šè¿‡JSONBå­—æ®µæ‰©å±•æ•°æ®ï¼Œé¿å…å¤§é‡æ–°è¡¨
3. **ä¼ä¸šé˜¶æ®µï¼š** æŒ‰éœ€æ·»åŠ è¡¨ç»“æ„ï¼Œä¸é¢„å…ˆè¿‡åº¦è®¾è®¡

**âš¡ å…³é”®ä¼˜åŒ–ç‚¹ï¼š**
- ä½¿ç”¨PostgreSQLå…¨æ–‡æœç´¢æ›¿ä»£å‘é‡æœç´¢ (é¿å…pgvectoræ‰©å±•)
- é€šè¿‡è¡¨åˆ†åŒºç®¡ç†å¤§é‡åˆ†ææ•°æ®
- JSONBå­˜å‚¨å¤æ‚ä¸šåŠ¡æ•°æ®ï¼Œä¿æŒè¡¨ç»“æ„ç®€æ´
- é›¶åœæœºçš„æ•°æ®è¿ç§»ç­–ç•¥

**ğŸ“Š é¢„æœŸæ€§èƒ½ï¼š**
- æ”¯æ’‘10ä¸‡ç”¨æˆ·å¹¶å‘
- å•è¡¨æŸ¥è¯¢<100ms
- å…¨æ–‡æœç´¢<500ms
- æœˆæ•°æ®å­˜å‚¨<50GB

### æ¶æ„æ¼”è¿›æŒ‡å¯¼åŸåˆ™

**ğŸ—ï¸ åˆ†é˜¶æ®µæ¶æ„ç­–ç•¥**

#### Phase 1-2: å•ä½“ä¼˜å…ˆ (Monolith First)
```typescript
// ç®€å•çš„æœåŠ¡å±‚ç»„ç»‡ï¼Œé¿å…å¾®æœåŠ¡å¤æ‚æ€§
export class NamingService {
  private openai: OpenAI
  private supabase: SupabaseClient

  async generateNames(request: NamingRequest): Promise<NamingResult> {
    // ç®€å•ç›´æ¥çš„å®ç°ï¼Œä¸“æ³¨åŠŸèƒ½è€Œéæ¶æ„
  }
}
```

#### Phase 3+: æŒ‰éœ€æ‹†åˆ† (Split When Necessary)
- å½“å›¢é˜Ÿè§„æ¨¡>10äººæ—¶è€ƒè™‘æ‹†åˆ†
- å½“å•ä¸€æœåŠ¡æˆä¸ºç“¶é¢ˆæ—¶æ‹†åˆ†
- ä¼˜å…ˆè€ƒè™‘æ•°æ®åº“åˆ†ç¦»è€ŒéæœåŠ¡æ‹†åˆ†

**ğŸ“Š ç›‘æ§ç­–ç•¥ï¼šç®€å•æœ‰æ•ˆ**

1. **MVPé˜¶æ®µï¼š** Sentryé”™è¯¯ç›‘æ§ + åŸºç¡€Supabaseç»Ÿè®¡
2. **å¢é•¿é˜¶æ®µï¼š** æ·»åŠ è‡ªå®šä¹‰åˆ†æè¡¨ï¼Œé¿å…å¼•å…¥ClickHouse
3. **æˆç†Ÿé˜¶æ®µï¼š** åŸºäºçœŸå®éœ€æ±‚é€‰æ‹©ä¸“ä¸šç›‘æ§å·¥å…·

**âš¡ æ€§èƒ½ä¼˜åŒ–é¡ºåº**

1. **æ•°æ®åº“ä¼˜åŒ–ï¼š** ç´¢å¼• > æŸ¥è¯¢ä¼˜åŒ– > åˆ†åŒº
2. **ç¼“å­˜ç­–ç•¥ï¼š** Redis > Cloudflare KV > åº”ç”¨å±‚ç¼“å­˜
3. **AIæˆæœ¬æ§åˆ¶ï¼š** ç¼“å­˜ > æ™ºèƒ½è·¯ç”± > æ¨¡å‹é€‰æ‹©

**ğŸ›¡ï¸ é”™è¯¯å¤„ç†å’Œé™çº§**

```typescript
// ç®€å•æœ‰æ•ˆçš„é™çº§ç­–ç•¥
export class NamingEngine {
  async generateWithFallback(request: NamingRequest): Promise<NamingResult> {
    try {
      return await this.openai.generate(request)
    } catch (error) {
      // é™çº§åˆ°é¢„è®¾åå­—åº“ + ç®€å•æ‹¼æ¥é€»è¾‘
      return await this.fallbackGeneration(request)
    }
  }
}
```

---

## ğŸ”„ åŸºäºcriteria-anyship-templateçš„å¤ç”¨æ¨¡å—

### ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†

åŸºäºæ¨¡æ¿ä¸­çš„ç”¨æˆ·ç³»ç»Ÿï¼Œæ‰©å±•ä¸­æ–‡èµ·åä¸šåŠ¡åœºæ™¯ï¼š

```typescript
// auth/ChineseNameAuth.ts - æ‰©å±•è®¤è¯ç³»ç»Ÿ
export class ChineseNameAuthService extends BaseAuthService {
  async createUserProfile(user: User): Promise<UserProfile> {
    // ç»§æ‰¿åŸºç¡€ç”¨æˆ·åˆ›å»ºé€»è¾‘
    const profile = await super.createUserProfile(user)

    // æ·»åŠ ä¸­æ–‡èµ·åç‰¹æœ‰çš„åˆå§‹åŒ–
    await this.initializeNamingProfile(profile.id)
    await this.grantFreeCredits(profile.id, 5) // æ–°ç”¨æˆ·5æ¬¡å…è´¹æœºä¼š

    return profile
  }

  private async initializeNamingProfile(userId: string): Promise<void> {
    await supabase.from('user_profiles').update({
      cultural_preferences: {},
      naming_history: [],
      favorite_styles: [],
      learning_progress: {
        pronunciation_level: 'beginner',
        cultural_knowledge: 'basic'
      }
    }).eq('id', userId)
  }
}
```

### æ”¯ä»˜å’Œè®¢é˜…ç³»ç»Ÿ

å¤ç”¨æ¨¡æ¿çš„Stripeé›†æˆï¼Œé€‚é…ä¸­æ–‡èµ·åä¸šåŠ¡ï¼š

```typescript
// services/payment/NamingPaymentService.ts
export class NamingPaymentService extends BasePaymentService {
  private namingPlans = {
    basic: {
      name: 'åŸºç¡€ç‰ˆ',
      price: 999, // $9.99
      credits: 20,
      features: ['æ— é™åŸºç¡€å‘½å', 'æ–‡åŒ–è§£é‡Š', 'å‘éŸ³éŸ³é¢‘']
    },
    premium: {
      name: 'ä¸“ä¸šç‰ˆ',
      price: 1999, // $19.99
      credits: 50,
      features: ['æ‰€æœ‰åŸºç¡€åŠŸèƒ½', 'äº”è¡Œå‘½å', 'è¯—æ„å‘½å', 'ä¹¦æ³•ç”Ÿæˆ']
    },
    enterprise: {
      name: 'ä¼ä¸šç‰ˆ',
      price: 4999, // $49.99
      credits: 200,
      features: ['æ‰€æœ‰åŠŸèƒ½', 'ä¼ä¸šå“ç‰Œå‘½å', 'ä¸“å®¶å’¨è¯¢', 'ä¼˜å…ˆæ”¯æŒ']
    }
  }

  async createNamingSubscription(userId: string, planType: keyof typeof this.namingPlans): Promise<StripeSession> {
    const plan = this.namingPlans[planType]

    return this.createSubscription({
      userId,
      planName: plan.name,
      amount: plan.price,
      metadata: {
        type: 'naming_subscription',
        plan: planType,
        credits: plan.credits
      }
    })
  }

  async handleNamingWebhook(event: StripeEvent): Promise<void> {
    if (event.type === 'checkout.session.completed') {
      const session = event.data.object as Stripe.Checkout.Session

      if (session.metadata?.type === 'naming_subscription') {
        await this.activateNamingSubscription(session)
      }
    }
  }

  private async activateNamingSubscription(session: Stripe.Checkout.Session): Promise<void> {
    const { plan, credits } = session.metadata!
    const userEmail = session.customer_email!

    // æ›´æ–°ç”¨æˆ·ç§¯åˆ†å’Œè®¢é˜…çŠ¶æ€
    await supabase.rpc('activate_naming_subscription', {
      user_email: userEmail,
      plan_type: plan,
      credits_to_add: parseInt(credits)
    })
  }
}
```

### å¤šè¯­è¨€å’Œå›½é™…åŒ–

åŸºäºæ¨¡æ¿çš„i18nç³»ç»Ÿï¼Œæ·»åŠ ä¸­æ–‡èµ·åä¸“ç”¨ç¿»è¯‘ï¼š

```typescript
// i18n/naming.ts
export const namingTranslations = {
  'zh-CN': {
    naming: {
      generator: {
        title: 'AIä¸­æ–‡èµ·å',
        subtitle: 'ä¸ºæ‚¨ç”Ÿæˆå¯Œæœ‰æ–‡åŒ–å†…æ¶µçš„ä¸­æ–‡åå­—',
        englishName: 'è¯·è¾“å…¥æ‚¨çš„è‹±æ–‡å',
        gender: 'æ€§åˆ«',
        style: 'é£æ ¼åå¥½',
        generate: 'ç”Ÿæˆåå­—'
      },
      results: {
        pronunciation: 'å‘éŸ³',
        meaning: 'å«ä¹‰',
        cultural: 'æ–‡åŒ–å†…æ¶µ',
        save: 'ä¿å­˜',
        share: 'åˆ†äº«',
        regenerate: 'é‡æ–°ç”Ÿæˆ'
      },
      styles: {
        traditional: 'ä¼ ç»Ÿ',
        modern: 'ç°ä»£',
        elegant: 'ä¼˜é›…',
        nature: 'è‡ªç„¶',
        literary: 'æ–‡å­¦'
      }
    }
  },
  'en': {
    naming: {
      generator: {
        title: 'AI Chinese Name Generator',
        subtitle: 'Generate culturally meaningful Chinese names',
        englishName: 'Enter your English name',
        gender: 'Gender',
        style: 'Style preference',
        generate: 'Generate Names'
      },
      // ... è‹±æ–‡ç¿»è¯‘
    }
  }
  // å…¶ä»–è¯­è¨€...
}
```

### APIå¯†é’¥ç®¡ç†

å¤ç”¨æ¨¡æ¿çš„APIå¯†é’¥ç³»ç»Ÿï¼Œç”¨äºä¼ä¸šå®¢æˆ·ï¼š

```typescript
// services/apikey/NamingAPIService.ts
export class NamingAPIService extends BaseAPIService {
  async createEnterpriseAPIKey(enterpriseId: string, permissions: APIPermissions): Promise<APIKey> {
    const apiKey = await super.createAPIKey({
      userId: enterpriseId,
      type: 'enterprise',
      permissions: {
        ...permissions,
        'naming:generate': true,
        'naming:bulk': permissions.level === 'premium',
        'naming:analytics': permissions.level === 'premium'
      }
    })

    return apiKey
  }

  async validateNamingRequest(apiKey: string, endpoint: string): Promise<ValidationResult> {
    const validation = await super.validateRequest(apiKey, endpoint)

    if (!validation.valid) {
      return validation
    }

    // æ£€æŸ¥ä¸­æ–‡èµ·åç‰¹æœ‰çš„é™åˆ¶
    const usage = await this.getNamingUsage(validation.keyId)

    if (endpoint === '/api/naming/generate' && usage.dailyRequests >= usage.dailyLimit) {
      return {
        valid: false,
        error: 'Daily naming quota exceeded',
        resetTime: usage.resetTime
      }
    }

    return validation
  }
}
```

---

## ğŸ“ˆ æŠ€æœ¯è·¯çº¿å›¾æ€»ç»“

### Phase 1: MVPåŸºç¡€ï¼ˆç¬¬1æœˆï¼‰
- âœ… åŸºç¡€å‘½åå‘å¯¼
- âœ… ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
- âœ… ç®€å•æ”¯ä»˜é›†æˆ
- âœ… ç§»åŠ¨ç«¯é€‚é…

### Phase 2: å¢å€¼åŠŸèƒ½ï¼ˆç¬¬2-3æœˆï¼‰
- ğŸ”„ äº”è¡Œå‘½åç³»ç»Ÿ
- ğŸ”„ è¯—æ„å‘½åå¼•æ“
- ğŸ”„ æ™ºèƒ½ä¹¦æ³•ç”Ÿæˆ
- ğŸ”„ æ–‡åŒ–æŠ¥å‘Šç³»ç»Ÿ

### Phase 3: ç¤¾äº¤å¢å¼ºï¼ˆç¬¬4-5æœˆï¼‰
- ğŸ”„ å‘éŸ³è¯„æµ‹ç³»ç»Ÿ
- ğŸ”„ ç”¨æˆ·ä½œå“ç”»å»Š
- ğŸ”„ ç¤¾äº¤åˆ†äº«åŠŸèƒ½
- ğŸ”„ ä¸ªæ€§åŒ–æ¨è

### Phase 4: ä¼ä¸šæœåŠ¡ï¼ˆç¬¬6-7æœˆï¼‰
- ğŸ”„ B2Bå‘½åå¹³å°
- ğŸ”„ ä¼ä¸šç®¡ç†åå°
- ğŸ”„ APIå¼€æ”¾å¹³å°
- ğŸ”„ é«˜çº§åˆ†æç³»ç»Ÿ

è¿™ä¸ªå®Œæ•´çš„æŠ€æœ¯æ–¹æ¡ˆåŒ…å«äº†ä»MVPåˆ°ä¼ä¸šçº§æœåŠ¡çš„å®Œæ•´å®æ–½è·¯å¾„ï¼Œå……åˆ†åˆ©ç”¨äº†criteria-anyship-templateçš„å¯å¤ç”¨åŠŸèƒ½æ¨¡å—ï¼ŒåŒæ—¶é’ˆå¯¹ä¸­æ–‡èµ·åçš„ä¸šåŠ¡ç‰¹ç‚¹è¿›è¡Œäº†æ·±åº¦å®šåˆ¶å’Œä¼˜åŒ–ã€‚