# 中文起名网站技术方案（MVP版）

## 🚀 基于 Cloudflare Pages + Supabase 的MVP方案

**核心目标：** 快速上线MVP，验证市场需求
**开发策略：** 精简功能，专注核心价值
**预估周期：** 18-20个工作日
**成本预算：** AI成本 $80/天，基础设施 <$50/月
**技术栈：** Next.js + Cloudflare Pages + Supabase + OpenAI

---

## 📊 MVP核心功能

### P1 核心功能（必须实现）
- ✅ 用户注册登录（Supabase Auth）
- ✅ AI中文起名（OpenAI GPT-4 Turbo）
- ✅ 名字保存和收藏
- ✅ 积分系统和支付（Stripe）
- ✅ 移动端适配

### P2 增值功能（后续迭代）
- 🔄 名字发音（TTS）
- 🔄 简单书法生成
- 🔄 分享功能

---

## 🏗️ 技术架构

### 核心技术栈（MVP精简版）
```typescript
const mvpTechStack = {
  // 前端框架
  frontend: "Next.js 15 (App Router)",
  deployment: "Cloudflare Pages + @cloudflare/next-on-pages",

  // 后端服务
  database: "Supabase PostgreSQL + RLS",
  auth: "Supabase Auth (邮箱+OAuth)",
  storage: "Supabase Storage",

  // AI服务
  ai: {
    generation: "OpenAI GPT-4 Turbo",
    audio: "OpenAI TTS-1 (P2阶段)"
  },

  // 支付系统
  payment: "Stripe Checkout + Webhooks",

  // UI框架
  ui: {
    styling: "Tailwind CSS",
    components: "Radix UI (基础组件)",
    responsive: "Mobile-first"
  },

  // 状态管理
  state: "React内置状态 (useState/useEffect)",

  // 缓存策略
  cache: "Cloudflare KV + 应用层缓存",

  // 监控工具
  monitoring: "Sentry + 自定义AI成本追踪"
}
```

### 系统架构图
```
用户浏览器
    ↓
Cloudflare CDN
    ↓
Cloudflare Pages (Next.js SSR)
    ↓
┌─────────────────────────────────────────┐
│        Pages Functions (Edge Runtime)   │
│  • app/api/generate-name                │
│  • app/api/stripe-webhook               │
│  • app/api/user-profile                 │
└─────────────────────────────────────────┘
    ↓
┌─────────────────┬─────────────────┐
│  Supabase       │ External APIs    │
│  • Auth         │ • OpenAI GPT-4   │
│  • PostgreSQL   │ • OpenAI TTS     │
│  • Storage      │ • Stripe         │
└─────────────────┴─────────────────┘
```

---

## 🎯 功能模块设计

### 核心业务模块
```typescript
const coreModules = {
  // 用户认证系统
  auth: {
    features: ["邮箱注册", "Google OAuth", "会话管理"],
    complexity: "简单",
    days: 2
  },

  // AI起名引擎
  nameGeneration: {
    features: ["GPT-4起名", "成本控制", "结果缓存"],
    complexity: "中等",
    days: 4
  },

  // 用户面板
  dashboard: {
    features: ["名字管理", "收藏功能", "历史记录"],
    complexity: "简单",
    days: 3
  },

  // 支付系统
  payment: {
    features: ["Stripe集成", "积分购买", "Webhook处理"],
    complexity: "中等",
    days: 3
  }
}
```

### AI成本控制策略
```typescript
const costControl = {
  dailyBudget: 80, // $80/天
  monthlyBudget: 2400, // $2400/月

  controls: {
    caching: "90%缓存命中率",
    rateLimit: "用户请求限制",
    monitoring: "实时成本追踪",
    alerts: "预算告警机制"
  },

  pricing: {
    freeUsers: "5次/天",
    paidUsers: "50次/天",
    costPerRequest: "$0.04-0.06"
  }
}
```

---

## 🏗️ 开发实施计划

### 项目初始化（1天）

```bash
# 1. 创建 Next.js 项目
npx create-next-app@latest chinesenamefinder --typescript --tailwind --app
cd chinesenamefinder

# 2. 安装核心依赖
npm install @supabase/supabase-js @supabase/auth-ui-react
npm install @radix-ui/react-* lucide-react
npm install stripe openai
npm install @cloudflare/next-on-pages wrangler

# 3. 开发工具
npm install -D @types/node typescript eslint prettier
npm install -D @sentry/nextjs
```

### 项目结构（精简版）
```
chinesenamefinder/
├── app/                          # Next.js App Router
│   ├── api/                     # API 路由
│   │   ├── generate-name/
│   │   ├── stripe-webhook/
│   │   └── user-profile/
│   ├── auth/                    # 认证页面
│   ├── dashboard/               # 用户面板
│   ├── pricing/                 # 定价页面
│   └── page.tsx                 # 首页
├── components/
│   ├── ui/                      # 基础 UI 组件
│   └── name-generator/          # 起名相关组件
├── lib/
│   ├── supabase.ts              # Supabase 客户端
│   ├── openai.ts                # OpenAI 客户端
│   ├── stripe.ts                # Stripe 客户端
│   └── utils.ts                 # 工具函数
├── types/                       # TypeScript 类型
└── middleware.ts                # 路由中间件
```

### 核心配置文件

#### next.config.mjs
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  trailingSlash: true,

  // Cloudflare Pages 图片优化
  images: {
    unoptimized: true
  },

  // 安全头部
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          { key: 'X-Frame-Options', value: 'DENY' },
          { key: 'X-Content-Type-Options', value: 'nosniff' }
        ]
      }
    ]
  }
}

export default nextConfig
```

#### wrangler.toml
```toml
name = "chinesenamefinder"
compatibility_date = "2024-09-01"

[[kv_namespaces]]
binding = "NEXT_CACHE"
id = "your-kv-namespace-id"
```

### Supabase 数据库设计（MVP简化版）

```sql
-- MVP 数据库架构（只保留核心表）

-- 1. 用户账户表
CREATE TABLE public.user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT NOT NULL,
  display_name TEXT,
  credits_remaining INTEGER DEFAULT 5,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. 名字记录表
CREATE TABLE public.names (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  english_name TEXT NOT NULL,
  chinese_name TEXT NOT NULL,
  pinyin TEXT NOT NULL,
  meaning TEXT,
  style TEXT DEFAULT 'modern',
  is_favorite BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. 支付记录表
CREATE TABLE public.payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  stripe_session_id TEXT UNIQUE,
  amount_cents INTEGER NOT NULL,
  credits_purchased INTEGER NOT NULL,
  status TEXT DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 行级安全策略
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.names ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "users_own_data" ON public.user_profiles
  FOR ALL USING (auth.uid() = id);
CREATE POLICY "users_own_names" ON public.names
  FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "users_own_payments" ON public.payments
  FOR SELECT USING (auth.uid() = user_id);

-- 基础索引
CREATE INDEX idx_names_user_created ON public.names(user_id, created_at DESC);
CREATE INDEX idx_names_favorites ON public.names(user_id) WHERE is_favorite = TRUE;
```

### Supabase 客户端配置

```typescript
// lib/supabase.ts
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

// 客户端
export const supabase = createClient(supabaseUrl, supabaseAnonKey)

// 服务端（API路由使用）
export const createServiceClient = () => {
  return createClient(
    supabaseUrl,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}
```

### 用户认证Hook

```typescript
// hooks/useAuth.ts
'use client'
import { useEffect, useState } from 'react'
import { User } from '@supabase/supabase-js'
import { supabase } from '@/lib/supabase'

export function useAuth() {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // 获取初始用户
    supabase.auth.getUser().then(({ data: { user } }) => {
      setUser(user)
      setLoading(false)
    })

    // 监听认证状态
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        setUser(session?.user ?? null)
        setLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  return { user, loading }
}
```

### AI起名引擎（核心功能）

```typescript
// lib/openai.ts - 简化的AI服务
import OpenAI from 'openai'

interface NameRequest {
  englishName: string
  gender: 'male' | 'female' | 'neutral'
  style: 'traditional' | 'modern' | 'elegant'
}

interface NameResult {
  chinese: string
  pinyin: string
  meaning: string
}

export class NameGenerator {
  private openai: OpenAI
  private readonly DAILY_BUDGET = 80 // $80/天
  private costTracker = new Map<string, number>()

  constructor(apiKey: string) {
    this.openai = new OpenAI({ apiKey })
  }

  async generateNames(request: NameRequest): Promise<NameResult[]> {
    // 成本检查
    await this.checkBudget()

    const prompt = `为"${request.englishName}"生成3个${request.gender === 'male' ? '男性' : request.gender === 'female' ? '女性' : ''}中文名字，${request.style}风格。返回JSON格式。`

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo',
      messages: [
        {
          role: 'system',
          content: '中文起名专家。返回JSON: {"names":[{"chinese":"王明","pinyin":"Wang Ming","meaning":"光明智慧"}]}'
        },
        { role: 'user', content: prompt }
      ],
      response_format: { type: 'json_object' },
      max_tokens: 800,
      temperature: 0.7
    })

    const result = JSON.parse(response.choices[0].message.content || '{}')

    // 记录成本
    await this.trackCost(0.04) // 估算每次请求$0.04

    return result.names || []
  }

  private async checkBudget(): Promise<void> {
    const today = new Date().toISOString().split('T')[0]
    const spent = this.costTracker.get(today) || 0

    if (spent >= this.DAILY_BUDGET) {
      throw new Error('今日AI预算已用完，请明天再试')
    }
  }

  private async trackCost(cost: number): Promise<void> {
    const today = new Date().toISOString().split('T')[0]
    const current = this.costTracker.get(today) || 0
    this.costTracker.set(today, current + cost)
  }
}
```

### API路由实现

```typescript
// app/api/generate-name/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { NameGenerator } from '@/lib/openai'
import { createServiceClient } from '@/lib/supabase'

export const runtime = 'edge'

export async function POST(request: NextRequest) {
  try {
    // 获取用户信息
    const authHeader = request.headers.get('Authorization')
    if (!authHeader) {
      return NextResponse.json({ error: '未授权' }, { status: 401 })
    }

    const token = authHeader.replace('Bearer ', '')
    const supabase = createServiceClient()

    const { data: { user }, error } = await supabase.auth.getUser(token)
    if (error || !user) {
      return NextResponse.json({ error: '认证失败' }, { status: 401 })
    }

    // 检查积分
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('credits_remaining')
      .eq('id', user.id)
      .single()

    if (!profile || profile.credits_remaining <= 0) {
      return NextResponse.json({ error: '积分不足' }, { status: 402 })
    }

    // 生成名字
    const requestData = await request.json()
    const generator = new NameGenerator(process.env.OPENAI_API_KEY!)
    const names = await generator.generateNames(requestData)

    // 保存结果并扣除积分
    await Promise.all([
      supabase.from('names').insert(
        names.map(name => ({
          user_id: user.id,
          english_name: requestData.englishName,
          chinese_name: name.chinese,
          pinyin: name.pinyin,
          meaning: name.meaning,
          style: requestData.style
        }))
      ),
      supabase
        .from('user_profiles')
        .update({ credits_remaining: profile.credits_remaining - 1 })
        .eq('id', user.id)
    ])

    return NextResponse.json({
      names,
      remainingCredits: profile.credits_remaining - 1
    })
  } catch (error) {
    console.error('Generate name error:', error)
    return NextResponse.json(
      { error: '服务器错误' },
      { status: 500 }
    )
  }
}
```

### Stripe支付集成

```typescript
// app/api/create-payment/route.ts
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'
import { createServiceClient } from '@/lib/supabase'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)

export async function POST(request: NextRequest) {
  try {
    const { planType } = await request.json()

    const plans = {
      basic: { credits: 20, price: 999 }, // $9.99
      standard: { credits: 50, price: 1999 }, // $19.99
      premium: { credits: 100, price: 3499 } // $34.99
    }

    const plan = plans[planType as keyof typeof plans]
    if (!plan) {
      return NextResponse.json({ error: '无效计划' }, { status: 400 })
    }

    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [{
        price_data: {
          currency: 'usd',
          product_data: {
            name: `积分包 - ${plan.credits}个积分`
          },
          unit_amount: plan.price
        },
        quantity: 1
      }],
      mode: 'payment',
      success_url: `${process.env.NEXT_PUBLIC_SITE_URL}/dashboard?success=true`,
      cancel_url: `${process.env.NEXT_PUBLIC_SITE_URL}/pricing`,
      metadata: {
        credits: plan.credits.toString()
      }
    })

    return NextResponse.json({ url: session.url })
  } catch (error) {
    return NextResponse.json(
      { error: '创建支付会话失败' },
      { status: 500 }
    )
  }
}
```

```typescript
// app/api/stripe-webhook/route.ts
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'
import { createServiceClient } from '@/lib/supabase'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!

export async function POST(request: NextRequest) {
  try {
    const body = await request.text()
    const sig = request.headers.get('stripe-signature')!

    const event = stripe.webhooks.constructEvent(body, sig, endpointSecret)

    if (event.type === 'checkout.session.completed') {
      const session = event.data.object as Stripe.Checkout.Session
      const credits = parseInt(session.metadata?.credits || '0')

      // 更新用户积分
      const supabase = createServiceClient()
      await supabase.rpc('add_credits', {
        user_email: session.customer_email,
        credits_to_add: credits
      })

      // 记录支付
      await supabase.from('payments').insert({
        stripe_session_id: session.id,
        amount_cents: session.amount_total || 0,
        credits_purchased: credits,
        status: 'completed'
      })
    }

    return NextResponse.json({ received: true })
  } catch (error) {
    return NextResponse.json(
      { error: 'Webhook处理失败' },
      { status: 400 }
    )
  }
}
```

---

## 📅 开发时间线

### Week 1: 基础架构（5天）
- **Day 1-2**: 项目初始化 + Supabase配置
- **Day 3-4**: 用户认证系统
- **Day 5**: 基础UI组件

### Week 2: 核心功能（5天）
- **Day 6-8**: AI起名引擎开发
- **Day 9**: 用户面板和名字管理
- **Day 10**: 功能测试和优化

### Week 3: 支付和部署（5天）
- **Day 11-12**: Stripe支付集成
- **Day 13**: 部署配置和优化
- **Day 14-15**: 测试和上线

### Week 4: 缓冲时间（3天）
- 问题修复和细节优化
- 用户反馈收集
- 性能监控和调优

---

## 🏆 成功指标

### MVP成功标准（3周后）
- **技术指标**: 99%可用性，AI成本<$80/天
- **业务指标**: 50+注册用户，5+付费用户
- **产品指标**: 核心功能100%可用

### 部署配置

```yaml
# .github/workflows/deploy.yml
name: Deploy to Cloudflare Pages

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'

      - name: Install and Build
        run: |
          npm ci
          npx @cloudflare/next-on-pages@1 build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: chinesenamefinder
          directory: .vercel/output/static
```

### 环境变量配置

```typescript
const requiredEnvVars = {
  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: "your-supabase-url",
  NEXT_PUBLIC_SUPABASE_ANON_KEY: "your-anon-key",
  SUPABASE_SERVICE_ROLE_KEY: "your-service-role-key",

  // OpenAI
  OPENAI_API_KEY: "your-openai-api-key",

  // Stripe
  STRIPE_SECRET_KEY: "your-stripe-secret-key",
  STRIPE_WEBHOOK_SECRET: "your-webhook-secret",
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: "your-publishable-key",

  // Cloudflare
  CLOUDFLARE_API_TOKEN: "your-api-token",
  CLOUDFLARE_ACCOUNT_ID: "your-account-id"
}
```

## 📋 实施检查清单

### ✅ 开发前准备
- [ ] 创建Supabase项目和数据库
- [ ] 获取OpenAI API密钥
- [ ] 设置Stripe账户和Webhook
- [ ] 配置Cloudflare Pages项目
- [ ] 设置GitHub仓库和Secrets

### ✅ MVP核心功能
- [ ] 用户注册登录系统
- [ ] AI起名引擎和成本控制
- [ ] 名字保存和收藏功能
- [ ] 积分系统和Stripe支付
- [ ] 移动端响应式设计

### ✅ 部署和监控
- [ ] 生产环境部署成功
- [ ] API健康检查端点
- [ ] 基础错误监控（Sentry）
- [ ] AI成本实时追踪
- [ ] 用户反馈收集机制

---

## 🎯 总结

这个优化后的MVP方案具备以下特点：

### ✅ 核心优势
- **技术可行**: 基于@cloudflare/next-on-pages解决方案，架构稳定
- **成本可控**: AI预算$80/天，基础设施<$50/月
- **开发高效**: 18-20天完成MVP，快速验证市场
- **扩展灵活**: 清晰的模块化设计，便于后续迭代

### 📈 预期成果
- **3周内**: MVP上线，核心功能可用
- **1个月内**: 获得首批用户反馈，验证产品需求
- **3个月内**: 基于用户反馈优化产品，实现产品-市场匹配

这个方案平衡了技术可行性、开发效率和成本控制，为中文起名网站的快速上线和迭代优化提供了坚实的技术基础。

---

## 🚀 完整产品技术路线图

基于PRD需求分析和criteria-anyship-template模板功能，以下是从MVP到完整产品的技术实施方案：

---

## 📋 Phase 2: 核心功能扩展（第2-3月）

### 增值服务模块

#### 2.1 AI五行命名系统
```typescript
// lib/wuxing.ts - 五行命名引擎
interface BirthInfo {
  date: string // YYYY-MM-DD
  time: string // HH:MM
  timezone: string // Asia/Shanghai
  gender: 'male' | 'female' | 'neutral'
}

interface WuxingAnalysis {
  elements: {
    metal: number    // 金
    wood: number     // 木
    water: number    // 水
    fire: number     // 火
    earth: number    // 土
  }
  lacking: string[]  // 缺失元素
  strong: string[]   // 强势元素
  suggestions: string[] // 命名建议
}

export class WuxingNameEngine {
  private calendar: ChineseCalendar

  constructor() {
    this.calendar = new ChineseCalendar()
  }

  async analyzeBirth(birthInfo: BirthInfo): Promise<WuxingAnalysis> {
    // 1. 转换为农历
    const lunarDate = this.calendar.solarToLunar(birthInfo.date)

    // 2. 计算八字
    const bazi = this.calculateBaZi(lunarDate, birthInfo.time)

    // 3. 五行分析
    const elements = this.analyzeWuxing(bazi)

    // 4. 生成建议
    const suggestions = this.generateSuggestions(elements, birthInfo.gender)

    return {
      elements,
      lacking: elements.lacking,
      strong: elements.strong,
      suggestions
    }
  }

  async generateWuxingNames(analysis: WuxingAnalysis, baseName: string): Promise<NameResult[]> {
    const prompt = this.buildWuxingPrompt(analysis, baseName)

    // 调用OpenAI生成符合五行要求的名字
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo',
      messages: [
        { role: 'system', content: WUXING_SYSTEM_PROMPT },
        { role: 'user', content: prompt }
      ],
      response_format: { type: 'json_object' },
      temperature: 0.7
    })

    return this.parseWuxingResults(response, analysis)
  }
}
```

#### 2.2 诗意命名系统
```typescript
// lib/poetry.ts - 诗意命名引擎
interface PoetrySource {
  id: string
  title: string        // 诗词标题
  author: string       // 作者
  dynasty: string      // 朝代
  content: string      // 原文
  translation: string  // 现代译文
  theme: string[]      // 主题标签
}

export class PoetryNameEngine {
  private poetryDB: PoetryDatabase
  private vectorSearch: VectorSearch

  async generatePoetryNames(
    theme: string,
    gender: 'male' | 'female' | 'neutral',
    style: 'classical' | 'elegant' | 'nature'
  ): Promise<PoetryNameResult[]> {

    // 1. 向量搜索相关诗词
    const poems = await this.vectorSearch.searchByTheme(theme, style)

    // 2. 筛选适合命名的诗句
    const namingVerses = this.filterNamingVerses(poems, gender)

    // 3. AI提取命名灵感
    const nameIdeas = await this.extractNameIdeas(namingVerses)

    // 4. 生成完整报告
    return nameIdeas.map(idea => ({
      name: idea.name,
      pinyin: idea.pinyin,
      meaning: idea.meaning,
      source: idea.source,
      report: this.generatePoetryReport(idea)
    }))
  }

  private async generatePoetryReport(nameIdea: NameIdea): Promise<PoetryReport> {
    return {
      originalVerse: nameIdea.source.content,
      author: nameIdea.source.author,
      dynasty: nameIdea.source.dynasty,
      translation: nameIdea.source.translation,
      culturalContext: await this.getCulturalContext(nameIdea.source),
      namingInspiration: nameIdea.inspiration,
      literaryAnalysis: await this.getLiteraryAnalysis(nameIdea.source)
    }
  }
}
```

#### 2.3 智能书法生成系统
```typescript
// lib/calligraphy.ts - 书法生成引擎
interface CalligraphyOptions {
  name: string
  style: 'kaishu' | 'xingshu' | 'caoshu' | 'lishu' | 'zhuanshu'
  layout: 'horizontal' | 'vertical' | 'square'
  background: 'paper' | 'silk' | 'stone' | 'transparent'
  resolution: 'standard' | 'high' | 'print'
}

export class CalligraphyEngine {
  private sdClient: StableDiffusionClient
  private stylePrompts: Map<string, string>

  constructor() {
    this.initializeStylePrompts()
  }

  async generateCalligraphy(options: CalligraphyOptions): Promise<CalligraphyResult> {
    // 1. 构建Stable Diffusion提示词
    const prompt = this.buildCalligraphyPrompt(options)

    // 2. 生成书法图像
    const image = await this.sdClient.textToImage({
      prompt,
      negative_prompt: CALLIGRAPHY_NEGATIVE_PROMPT,
      width: this.getResolutionWidth(options.resolution),
      height: this.getResolutionHeight(options.resolution),
      steps: 30,
      cfg_scale: 7,
      sampler: 'DPM++ 2M Karras'
    })

    // 3. 后处理优化
    const optimizedImage = await this.postProcessCalligraphy(image, options)

    // 4. 生成多种格式
    const formats = await this.generateMultipleFormats(optimizedImage)

    return {
      original: optimizedImage,
      formats,
      metadata: this.generateMetadata(options),
      downloadUrls: await this.uploadToStorage(formats)
    }
  }

  private buildCalligraphyPrompt(options: CalligraphyOptions): string {
    const basePrompt = `Chinese calligraphy of "${options.name}"`
    const stylePrompt = this.stylePrompts.get(options.style)
    const layoutPrompt = this.getLayoutPrompt(options.layout)
    const backgroundPrompt = this.getBackgroundPrompt(options.background)

    return `${basePrompt}, ${stylePrompt}, ${layoutPrompt}, ${backgroundPrompt}, masterpiece, high quality, traditional Chinese art`
  }
}
```

### 渐进式数据库演进设计

#### Phase 1.5: MVP扩展（无破坏性变更）
```sql
-- 扩展现有表结构，保持向下兼容
ALTER TABLE public.user_profiles ADD COLUMN IF NOT EXISTS
  preferences JSONB DEFAULT '{}', -- 用户偏好设置
  subscription_tier TEXT DEFAULT 'free', -- 订阅等级
  cultural_preferences JSONB DEFAULT '{}', -- 文化偏好
  updated_at TIMESTAMPTZ DEFAULT NOW();

ALTER TABLE public.names ADD COLUMN IF NOT EXISTS
  generation_type TEXT DEFAULT 'basic', -- 'basic', 'wuxing', 'poetry'
  source_data JSONB DEFAULT '{}', -- 扩展数据存储
  quality_score INTEGER CHECK (quality_score BETWEEN 1 AND 100),
  metadata JSONB DEFAULT '{}'; -- 元数据（五行、诗词来源等）

-- 新增内容管理表（简化设计）
CREATE TABLE IF NOT EXISTS public.content_sources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN ('poetry', 'cultural_data', 'calligraphy_template')),
  title TEXT NOT NULL,
  content_data JSONB NOT NULL, -- 存储诗词、文化知识等
  tags TEXT[], -- 主题标签
  search_text TEXT, -- 全文搜索字段
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 用户作品表（统一管理所有类型作品）
CREATE TABLE IF NOT EXISTS public.user_works (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  name_id UUID REFERENCES public.names(id),
  work_type TEXT NOT NULL CHECK (work_type IN ('calligraphy', 'cultural_report', 'shared_story')),
  work_data JSONB NOT NULL, -- 作品数据
  is_public BOOLEAN DEFAULT FALSE,
  likes_count INTEGER DEFAULT 0,
  views_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建搜索优化索引
CREATE INDEX IF NOT EXISTS idx_content_sources_type_tags ON public.content_sources USING GIN(type, tags);
CREATE INDEX IF NOT EXISTS idx_content_sources_search ON public.content_sources USING GIN(to_tsvector('chinese', search_text));
CREATE INDEX IF NOT EXISTS idx_user_works_type_public ON public.user_works(work_type, is_public) WHERE is_public = TRUE;
CREATE INDEX IF NOT EXISTS idx_names_generation_type ON public.names(generation_type, created_at DESC);

-- 行级安全策略
ALTER TABLE public.content_sources ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_works ENABLE ROW LEVEL SECURITY;

CREATE POLICY "content_sources_public_read" ON public.content_sources
  FOR SELECT USING (true); -- 内容源公开可读

CREATE POLICY "users_own_works" ON public.user_works
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "public_works_readable" ON public.user_works
  FOR SELECT USING (is_public = TRUE OR auth.uid() = user_id);
```

#### Phase 2+: 按需扩展策略
```sql
-- 仅在真正需要时才扩展，避免过度设计

-- 企业客户表（仅B2B阶段需要）
CREATE TABLE IF NOT EXISTS public.enterprise_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  company_name TEXT NOT NULL,
  contact_info JSONB NOT NULL, -- 联系信息
  subscription_data JSONB DEFAULT '{}', -- 订阅数据
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 分析数据表（简化版，避免引入ClickHouse）
CREATE TABLE IF NOT EXISTS public.usage_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  event_type TEXT NOT NULL,
  event_data JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- 按月分区，便于数据管理
CREATE TABLE public.usage_analytics_current PARTITION OF public.usage_analytics
  FOR VALUES FROM (date_trunc('month', CURRENT_DATE)) TO (date_trunc('month', CURRENT_DATE + interval '1 month'));

-- 索引优化
CREATE INDEX idx_analytics_user_type_time ON public.usage_analytics(user_id, event_type, created_at DESC);
CREATE INDEX idx_analytics_type_time ON public.usage_analytics(event_type, created_at DESC) WHERE created_at >= CURRENT_DATE - interval '30 days';
```

#### 数据迁移策略
```sql
-- 平滑迁移函数，保证零停机
CREATE OR REPLACE FUNCTION migrate_name_data()
RETURNS void AS $$
BEGIN
  -- 将现有基础名字标记为 'basic' 类型
  UPDATE public.names
  SET generation_type = 'basic',
      metadata = '{"version": "1.0", "migration": "auto"}'
  WHERE generation_type IS NULL;

  -- 创建内容搜索索引
  INSERT INTO public.content_sources (type, title, content_data, tags, search_text)
  SELECT 'poetry', '默认诗词库', '{"status": "placeholder"}', ARRAY['classical'], '诗词'
  WHERE NOT EXISTS (SELECT 1 FROM public.content_sources WHERE type = 'poetry');
END;
$$ LANGUAGE plpgsql;
```

#### 搜索优化（避免向量搜索复杂性）
```sql
-- 基于PostgreSQL全文搜索，无需额外扩展
CREATE OR REPLACE FUNCTION search_poetry_content(
  search_term TEXT,
  theme_filter TEXT[] DEFAULT NULL
) RETURNS TABLE (
  id UUID,
  title TEXT,
  content_data JSONB,
  relevance REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cs.id,
    cs.title,
    cs.content_data,
    ts_rank(to_tsvector('chinese', cs.search_text), plainto_tsquery('chinese', search_term)) AS relevance
  FROM public.content_sources cs
  WHERE cs.type = 'poetry'
    AND to_tsvector('chinese', cs.search_text) @@ plainto_tsquery('chinese', search_term)
    AND (theme_filter IS NULL OR cs.tags && theme_filter)
  ORDER BY relevance DESC
  LIMIT 20;
END;
$$ LANGUAGE plpgsql;
```

---

## 📱 Phase 3: 用户体验增强（第4-5月）

### 3.1 发音评测系统

```typescript
// lib/pronunciation.ts - 发音评测引擎
interface PronunciationAssessment {
  name: string
  userAudio: Blob
  targetPinyin: string
}

interface AssessmentResult {
  overallScore: number // 0-100
  toneAccuracy: number
  pronunciationAccuracy: number
  fluency: number
  feedback: PronunciationFeedback[]
  suggestions: string[]
}

export class PronunciationEngine {
  private speechSDK: AzureSpeechSDK

  async assessPronunciation(assessment: PronunciationAssessment): Promise<AssessmentResult> {
    // 1. 上传音频到临时存储
    const audioUrl = await this.uploadTempAudio(assessment.userAudio)

    // 2. 调用Azure语音评测API
    const result = await this.speechSDK.pronunciationAssessment({
      audioUrl,
      referenceText: assessment.targetPinyin,
      language: 'zh-CN',
      granularity: 'phoneme'
    })

    // 3. 解析评测结果
    const scores = this.parseAssessmentScores(result)

    // 4. 生成个性化建议
    const suggestions = await this.generateSuggestions(scores, assessment.targetPinyin)

    return {
      overallScore: scores.overall,
      toneAccuracy: scores.tone,
      pronunciationAccuracy: scores.pronunciation,
      fluency: scores.fluency,
      feedback: scores.feedback,
      suggestions
    }
  }

  async generatePronunciationGuide(name: string, pinyin: string): Promise<PronunciationGuide> {
    // 生成发音指导音频和可视化图表
    const nativeAudio = await this.generateNativeAudio(pinyin)
    const toneChart = await this.generateToneChart(pinyin)
    const phoneticBreakdown = this.analyzePhonetics(pinyin)

    return {
      nativeAudio,
      toneChart,
      phoneticBreakdown,
      practiceExercises: this.generatePracticeExercises(pinyin)
    }
  }
}
```

### 3.2 社交分享系统

```typescript
// lib/sharing.ts - 分享功能引擎
interface ShareContent {
  type: 'name' | 'calligraphy' | 'culture_report'
  id: string
  customMessage?: string
  platforms: SocialPlatform[]
}

interface ShareResult {
  shareUrl: string
  previewCard: ShareCard
  analytics: ShareAnalytics
}

export class SharingEngine {
  async createShareContent(content: ShareContent): Promise<ShareResult> {
    // 1. 生成分享页面
    const shareUrl = await this.generateSharePage(content)

    // 2. 创建预览卡片
    const previewCard = await this.generatePreviewCard(content)

    // 3. 设置分析追踪
    const analytics = this.setupShareAnalytics(content)

    return { shareUrl, previewCard, analytics }
  }

  private async generateSharePage(content: ShareContent): Promise<string> {
    const shareId = generateShareId()

    // 创建静态分享页面
    const shareData = await this.getShareData(content)
    const htmlContent = await this.renderShareTemplate(shareData)

    // 上传到Cloudflare Pages
    await this.uploadSharePage(shareId, htmlContent)

    return `${process.env.NEXT_PUBLIC_SITE_URL}/share/${shareId}`
  }

  private async generatePreviewCard(content: ShareContent): Promise<ShareCard> {
    // 根据内容类型生成不同的预览卡片
    switch (content.type) {
      case 'name':
        return this.generateNameCard(content.id)
      case 'calligraphy':
        return this.generateCalligraphyCard(content.id)
      case 'culture_report':
        return this.generateReportCard(content.id)
      default:
        throw new Error('Unsupported content type')
    }
  }
}
```

### 3.3 用户作品画廊

```typescript
// components/gallery/UserGallery.tsx
interface GalleryWork {
  id: string
  type: 'name' | 'calligraphy' | 'story'
  title: string
  author: User
  thumbnail: string
  likes: number
  views: number
  tags: string[]
  createdAt: Date
  isPublic: boolean
}

export function UserGallery() {
  const [works, setWorks] = useState<GalleryWork[]>([])
  const [filter, setFilter] = useState<GalleryFilter>('all')
  const [sortBy, setSortBy] = useState<SortOption>('popular')

  return (
    <div className="gallery-container">
      <GalleryFilters
        currentFilter={filter}
        onFilterChange={setFilter}
        sortBy={sortBy}
        onSortChange={setSortBy}
      />

      <InfiniteScroll
        items={works}
        renderItem={(work) => (
          <GalleryWorkCard
            work={work}
            onLike={handleLike}
            onShare={handleShare}
            onView={handleView}
          />
        )}
        loadMore={loadMoreWorks}
        hasMore={hasMoreWorks}
      />
    </div>
  )
}

// 社区互动功能
export function GalleryWorkCard({ work, onLike, onShare, onView }: GalleryWorkCardProps) {
  return (
    <Card className="gallery-work-card">
      <CardHeader>
        <div className="flex items-center justify-between">
          <UserAvatar user={work.author} />
          <DropdownMenu>
            <DropdownMenuTrigger>
              <MoreHorizontal className="h-4 w-4" />
            </DropdownMenuTrigger>
            <DropdownMenuContent>
              <DropdownMenuItem onClick={() => onShare(work.id)}>
                分享作品
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => window.open(`/works/${work.id}`)}>
                查看详情
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </CardHeader>

      <CardContent>
        <WorkPreview work={work} onClick={() => onView(work.id)} />
        <WorkMetadata work={work} />
      </CardContent>

      <CardFooter>
        <div className="flex items-center justify-between w-full">
          <div className="flex items-center space-x-4">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onLike(work.id)}
              className="flex items-center space-x-1"
            >
              <Heart className="h-4 w-4" />
              <span>{work.likes}</span>
            </Button>
            <span className="text-sm text-muted-foreground">
              {work.views} 次查看
            </span>
          </div>
          <WorkTags tags={work.tags} />
        </div>
      </CardFooter>
    </Card>
  )
}
```

---

## 🏢 Phase 4: B2B企业服务（第6-7月）

### 4.1 企业命名服务平台

```typescript
// app/api/enterprise/naming/route.ts
interface EnterpriseNamingRequest {
  companyInfo: {
    name: string
    industry: string
    targetMarket: string[]
    brandValues: string[]
  }
  namingRequirements: {
    type: 'brand' | 'product' | 'subsidiary'
    style: 'modern' | 'traditional' | 'international'
    length: 'short' | 'medium' | 'long'
    avoidWords: string[]
    preferredElements: string[]
  }
  budget: 'basic' | 'professional' | 'premium'
  timeline: string
}

interface EnterpriseNamingResult {
  proposals: EnterpriseNameProposal[]
  marketAnalysis: MarketAnalysis
  trademarkCheck: TrademarkReport
  culturalReport: CulturalValidation
  recommendedNext: string[]
}

export async function POST(request: NextRequest) {
  const namingRequest: EnterpriseNamingRequest = await request.json()

  // 1. 验证企业身份和权限
  const user = await authenticateEnterpriseUser(request)
  if (!user || user.accountType !== 'enterprise') {
    return NextResponse.json({ error: '需要企业账户权限' }, { status: 403 })
  }

  // 2. 创建企业命名项目
  const project = await createNamingProject(namingRequest, user.id)

  // 3. AI生成候选名称
  const proposals = await generateEnterpriseNames(namingRequest)

  // 4. 市场分析和验证
  const marketAnalysis = await performMarketAnalysis(proposals, namingRequest.companyInfo)

  // 5. 商标可申请性检查
  const trademarkCheck = await checkTrademarkAvailability(proposals)

  // 6. 文化适配性验证
  const culturalReport = await validateCulturalAppropriateness(proposals, namingRequest.companyInfo.targetMarket)

  // 7. 生成综合报告
  const result: EnterpriseNamingResult = {
    proposals,
    marketAnalysis,
    trademarkCheck,
    culturalReport,
    recommendedNext: generateRecommendations(proposals, marketAnalysis)
  }

  // 8. 保存项目结果
  await saveProjectResults(project.id, result)

  return NextResponse.json(result)
}

async function generateEnterpriseNames(request: EnterpriseNamingRequest): Promise<EnterpriseNameProposal[]> {
  const enterprisePrompt = buildEnterprisePrompt(request)

  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo',
    messages: [
      { role: 'system', content: ENTERPRISE_NAMING_SYSTEM_PROMPT },
      { role: 'user', content: enterprisePrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.8
  })

  const rawResults = JSON.parse(response.choices[0].message.content || '{}')

  // 增强每个提案的详细信息
  return Promise.all(rawResults.proposals.map(async (proposal: any) => ({
    ...proposal,
    marketingAngles: await generateMarketingAngles(proposal),
    competitorAnalysis: await analyzeCompetitors(proposal, request.companyInfo.industry),
    brandingStrategy: await generateBrandingStrategy(proposal),
    riskAssessment: await assessNamingRisks(proposal)
  })))
}
```

### 4.2 企业管理后台

```typescript
// app/[locale]/(admin)/enterprise/projects/page.tsx
export default function EnterpriseProjectsPage() {
  const [projects, setProjects] = useState<EnterpriseProject[]>([])
  const [filter, setFilter] = useState<ProjectFilter>('all')

  return (
    <div className="enterprise-dashboard">
      <DashboardHeader />

      <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
        <StatCard
          title="进行中项目"
          value={projects.filter(p => p.status === 'in_progress').length}
          icon={<Clock className="h-4 w-4" />}
        />
        <StatCard
          title="已完成项目"
          value={projects.filter(p => p.status === 'completed').length}
          icon={<CheckCircle className="h-4 w-4" />}
        />
        <StatCard
          title="本月收入"
          value={`$${calculateMonthlyRevenue(projects)}`}
          icon={<DollarSign className="h-4 w-4" />}
        />
        <StatCard
          title="客户满意度"
          value={`${calculateSatisfactionRate(projects)}%`}
          icon={<Star className="h-4 w-4" />}
        />
      </div>

      <ProjectFilters filter={filter} onFilterChange={setFilter} />

      <ProjectsTable
        projects={filteredProjects}
        onProjectClick={handleProjectClick}
        onStatusUpdate={handleStatusUpdate}
      />
    </div>
  )
}

// 企业客户关系管理
function ProjectsTable({ projects, onProjectClick, onStatusUpdate }: ProjectsTableProps) {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>项目名称</TableHead>
          <TableHead>客户</TableHead>
          <TableHead>类型</TableHead>
          <TableHead>状态</TableHead>
          <TableHead>预算</TableHead>
          <TableHead>截止日期</TableHead>
          <TableHead>操作</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {projects.map((project) => (
          <TableRow key={project.id}>
            <TableCell>
              <button
                onClick={() => onProjectClick(project.id)}
                className="font-medium text-blue-600 hover:underline"
              >
                {project.name}
              </button>
            </TableCell>
            <TableCell>
              <div className="flex items-center space-x-2">
                <Avatar className="h-8 w-8">
                  <AvatarImage src={project.client.avatar} />
                  <AvatarFallback>{project.client.name.charAt(0)}</AvatarFallback>
                </Avatar>
                <span>{project.client.name}</span>
              </div>
            </TableCell>
            <TableCell>
              <Badge variant={getTypeVariant(project.type)}>
                {project.type}
              </Badge>
            </TableCell>
            <TableCell>
              <StatusBadge
                status={project.status}
                onUpdate={(newStatus) => onStatusUpdate(project.id, newStatus)}
              />
            </TableCell>
            <TableCell>${project.budget.toLocaleString()}</TableCell>
            <TableCell>{formatDate(project.deadline)}</TableCell>
            <TableCell>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" className="h-8 w-8 p-0">
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onProjectClick(project.id)}>
                    查看详情
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => downloadProjectReport(project.id)}>
                    下载报告
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => contactClient(project.client.id)}>
                    联系客户
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}
```

---

## 🔧 完整技术架构进阶版

### 数据库设计原则

**📋 设计理念：渐进式演进，避免过度工程化**

1. **MVP阶段：** 保持3张核心表的简洁性
2. **扩展阶段：** 通过JSONB字段扩展数据，避免大量新表
3. **企业阶段：** 按需添加表结构，不预先过度设计

**⚡ 关键优化点：**
- 使用PostgreSQL全文搜索替代向量搜索 (避免pgvector扩展)
- 通过表分区管理大量分析数据
- JSONB存储复杂业务数据，保持表结构简洁
- 零停机的数据迁移策略

**📊 预期性能：**
- 支撑10万用户并发
- 单表查询<100ms
- 全文搜索<500ms
- 月数据存储<50GB

### 架构演进指导原则

**🏗️ 分阶段架构策略**

#### Phase 1-2: 单体优先 (Monolith First)
```typescript
// 简单的服务层组织，避免微服务复杂性
export class NamingService {
  private openai: OpenAI
  private supabase: SupabaseClient

  async generateNames(request: NamingRequest): Promise<NamingResult> {
    // 简单直接的实现，专注功能而非架构
  }
}
```

#### Phase 3+: 按需拆分 (Split When Necessary)
- 当团队规模>10人时考虑拆分
- 当单一服务成为瓶颈时拆分
- 优先考虑数据库分离而非服务拆分

**📊 监控策略：简单有效**

1. **MVP阶段：** Sentry错误监控 + 基础Supabase统计
2. **增长阶段：** 添加自定义分析表，避免引入ClickHouse
3. **成熟阶段：** 基于真实需求选择专业监控工具

**⚡ 性能优化顺序**

1. **数据库优化：** 索引 > 查询优化 > 分区
2. **缓存策略：** Redis > Cloudflare KV > 应用层缓存
3. **AI成本控制：** 缓存 > 智能路由 > 模型选择

**🛡️ 错误处理和降级**

```typescript
// 简单有效的降级策略
export class NamingEngine {
  async generateWithFallback(request: NamingRequest): Promise<NamingResult> {
    try {
      return await this.openai.generate(request)
    } catch (error) {
      // 降级到预设名字库 + 简单拼接逻辑
      return await this.fallbackGeneration(request)
    }
  }
}
```

---

## 🔄 基于criteria-anyship-template的复用模块

### 用户认证和权限管理

基于模板中的用户系统，扩展中文起名业务场景：

```typescript
// auth/ChineseNameAuth.ts - 扩展认证系统
export class ChineseNameAuthService extends BaseAuthService {
  async createUserProfile(user: User): Promise<UserProfile> {
    // 继承基础用户创建逻辑
    const profile = await super.createUserProfile(user)

    // 添加中文起名特有的初始化
    await this.initializeNamingProfile(profile.id)
    await this.grantFreeCredits(profile.id, 5) // 新用户5次免费机会

    return profile
  }

  private async initializeNamingProfile(userId: string): Promise<void> {
    await supabase.from('user_profiles').update({
      cultural_preferences: {},
      naming_history: [],
      favorite_styles: [],
      learning_progress: {
        pronunciation_level: 'beginner',
        cultural_knowledge: 'basic'
      }
    }).eq('id', userId)
  }
}
```

### 支付和订阅系统

复用模板的Stripe集成，适配中文起名业务：

```typescript
// services/payment/NamingPaymentService.ts
export class NamingPaymentService extends BasePaymentService {
  private namingPlans = {
    basic: {
      name: '基础版',
      price: 999, // $9.99
      credits: 20,
      features: ['无限基础命名', '文化解释', '发音音频']
    },
    premium: {
      name: '专业版',
      price: 1999, // $19.99
      credits: 50,
      features: ['所有基础功能', '五行命名', '诗意命名', '书法生成']
    },
    enterprise: {
      name: '企业版',
      price: 4999, // $49.99
      credits: 200,
      features: ['所有功能', '企业品牌命名', '专家咨询', '优先支持']
    }
  }

  async createNamingSubscription(userId: string, planType: keyof typeof this.namingPlans): Promise<StripeSession> {
    const plan = this.namingPlans[planType]

    return this.createSubscription({
      userId,
      planName: plan.name,
      amount: plan.price,
      metadata: {
        type: 'naming_subscription',
        plan: planType,
        credits: plan.credits
      }
    })
  }

  async handleNamingWebhook(event: StripeEvent): Promise<void> {
    if (event.type === 'checkout.session.completed') {
      const session = event.data.object as Stripe.Checkout.Session

      if (session.metadata?.type === 'naming_subscription') {
        await this.activateNamingSubscription(session)
      }
    }
  }

  private async activateNamingSubscription(session: Stripe.Checkout.Session): Promise<void> {
    const { plan, credits } = session.metadata!
    const userEmail = session.customer_email!

    // 更新用户积分和订阅状态
    await supabase.rpc('activate_naming_subscription', {
      user_email: userEmail,
      plan_type: plan,
      credits_to_add: parseInt(credits)
    })
  }
}
```

### 多语言和国际化

基于模板的i18n系统，添加中文起名专用翻译：

```typescript
// i18n/naming.ts
export const namingTranslations = {
  'zh-CN': {
    naming: {
      generator: {
        title: 'AI中文起名',
        subtitle: '为您生成富有文化内涵的中文名字',
        englishName: '请输入您的英文名',
        gender: '性别',
        style: '风格偏好',
        generate: '生成名字'
      },
      results: {
        pronunciation: '发音',
        meaning: '含义',
        cultural: '文化内涵',
        save: '保存',
        share: '分享',
        regenerate: '重新生成'
      },
      styles: {
        traditional: '传统',
        modern: '现代',
        elegant: '优雅',
        nature: '自然',
        literary: '文学'
      }
    }
  },
  'en': {
    naming: {
      generator: {
        title: 'AI Chinese Name Generator',
        subtitle: 'Generate culturally meaningful Chinese names',
        englishName: 'Enter your English name',
        gender: 'Gender',
        style: 'Style preference',
        generate: 'Generate Names'
      },
      // ... 英文翻译
    }
  }
  // 其他语言...
}
```

### API密钥管理

复用模板的API密钥系统，用于企业客户：

```typescript
// services/apikey/NamingAPIService.ts
export class NamingAPIService extends BaseAPIService {
  async createEnterpriseAPIKey(enterpriseId: string, permissions: APIPermissions): Promise<APIKey> {
    const apiKey = await super.createAPIKey({
      userId: enterpriseId,
      type: 'enterprise',
      permissions: {
        ...permissions,
        'naming:generate': true,
        'naming:bulk': permissions.level === 'premium',
        'naming:analytics': permissions.level === 'premium'
      }
    })

    return apiKey
  }

  async validateNamingRequest(apiKey: string, endpoint: string): Promise<ValidationResult> {
    const validation = await super.validateRequest(apiKey, endpoint)

    if (!validation.valid) {
      return validation
    }

    // 检查中文起名特有的限制
    const usage = await this.getNamingUsage(validation.keyId)

    if (endpoint === '/api/naming/generate' && usage.dailyRequests >= usage.dailyLimit) {
      return {
        valid: false,
        error: 'Daily naming quota exceeded',
        resetTime: usage.resetTime
      }
    }

    return validation
  }
}
```

---

## 📈 技术路线图总结

### Phase 1: MVP基础（第1月）
- ✅ 基础命名向导
- ✅ 用户认证系统
- ✅ 简单支付集成
- ✅ 移动端适配

### Phase 2: 增值功能（第2-3月）
- 🔄 五行命名系统
- 🔄 诗意命名引擎
- 🔄 智能书法生成
- 🔄 文化报告系统

### Phase 3: 社交增强（第4-5月）
- 🔄 发音评测系统
- 🔄 用户作品画廊
- 🔄 社交分享功能
- 🔄 个性化推荐

### Phase 4: 企业服务（第6-7月）
- 🔄 B2B命名平台
- 🔄 企业管理后台
- 🔄 API开放平台
- 🔄 高级分析系统

这个完整的技术方案包含了从MVP到企业级服务的完整实施路径，充分利用了criteria-anyship-template的可复用功能模块，同时针对中文起名的业务特点进行了深度定制和优化。